---
title: "Recovery DE Analysis"
author: "Emma M Pfortmiller"
date: "2025-02-10"
site: workflowr::wflow_site
output:
  workflowr::wflow_html:
    toc: true
    toc_depth: 2
    toc_float: true
    theme: journal
editor_options: 
  chunk_output_type: inline
---

Welcome to my research website.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{css, echo=FALSE}
pre {
  max-height: 400px;
  overflow-y: auto;
}

pre[class] {
  max-height: 200px;
}
```

```{r Libraries, collapse=TRUE, include=FALSE, results='hide'}
library(ggplot2)
library(reshape2)
library(hrbrthemes)
library(tibble)
library(tidyverse)
library(edgebundleR)
library(readxl)
library(readr)
library(edgeR)
library(pheatmap)
library(ggfortify)
library(PCAtools)
library(RColorBrewer)
library(biomaRt)
library(RUVSeq)
library(Rfast)
```

To begin the differential expression (DE) pipeline, I will start by making the data frames I will use.

For DE, I need a dataframe that is:
1. log2cpm transformed
2. filtered by rowMeans > 0
3. rownames from the log2cpm filter pulled out
4. has only the shared rows (genes) that are present in the filtered log2cpm dataframe

I made a filtered gene object based on these parameters, and will filter the counts_DE object by this


```{r Data Frames for Counts DE}

counts_DE_raw <- read_csv("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_RNAseq/featureCounts_Concat_Matrix_AllSamples_EMP_250220.csv")
#View(counts_DE)

fC_Matrix_Full <- readRDS("data/fC_Matrix_Full.RDS")

Counts_Full_df <- data.frame(fC_Matrix_Full)

#filter this dataframe by the filtered gene list I have
filt_gene_list <- readRDS("data/filt_gene_list.RDS")
counts_DE_df <- Counts_Full_df[! (rownames(Counts_Full_df) %in% filt_gene_list), ]

#saveRDS(counts_DE_df, "data/counts_DE_df.RDS")

counts_DE_norep <- as.data.frame(counts_DE_df) %>% 
        dplyr::select(-(contains("Ind6REP")))

#saveRDS(counts_DE_norep, "data/counts_DE_norep.RDS")

#now I've removed Ind6 REP
##I should have 54 samples if not including Ind6REP
dim(counts_DE_df)
dim(counts_DE_norep)

```

Now that I've put together my data, let's begin DE!

```{r Differential Expression Analysis, collapse=TRUE}

group_1 <- rep(c("DOX_24","FLUO_24",
                                "DMSO_24",
                                "DOX_24rec",
                                "FLUO_24rec",
                                "DMSO_24rec",
                                "DOX_144rec",
                                "FLUO_144rec",
                                "DMSO_144rec"), 6)

group_2 <- rep(c("DOX_24","FLUO_24",
                                "DMSO_24",
                                "DOX_24rec",
                                "FLUO_24rec",
                                "DMSO_24rec",
                                "DOX_144rec",
                                "FLUO_144rec",
                                "DMSO_144rec"), 7)

dge <- DGEList.data.frame(counts = counts_DE_df, group = group_2, genes = row.names(counts_DE_df))

#check the inital file before norm factors are calculated
#dge$samples

#calculate the normalization factors with method TMM
dge_calc <- calcNormFactors(dge, method = "TMM")

#check final file after norm calculation
#dge_calc$samples

#after calculating norm factors, that column was changed.

#View(dge_calc)

#Pull out factors
snames <- data.frame("samples" = colnames(dge_calc)) %>% separate_wider_delim(., cols = samples, names = c("Treatment", "Time", "Individual"), delim = "_", cols_remove = FALSE)

#snames_list <- as.list(snames)

snames_time <- snames$Time
snames_tx <- snames$Treatment
snames_ind <- snames$Individual

#Create my model matrix
mm_r <- model.matrix(~0 + group_2)

p <- voom(dge_calc$counts, mm_r, plot = TRUE)

corfit <- duplicateCorrelation(p, mm_r, block = snames_ind)

v <- voom(dge_calc$counts, mm_r, block = snames_ind, correlation = corfit$consensus)

fit <- lmFit(v, mm_r, block = snames_ind, correlation = corfit$consensus)

#make sure to check which order the columns are in - otherwise they won't match right (it was moved into alphabetical and number order)
colnames(mm_r) <- c("DMSO_144rec","DMSO_24","DMSO_24rec","DOX_144rec","DOX_24","DOX_24rec","FLUO_144rec","FLUO_24","FLUO_24rec")

cm_r <- makeContrasts(
        V.D24 = DOX_24 - DMSO_24,
        V.F24 = FLUO_24 - DMSO_24,
        V.D24r = DOX_24rec - DMSO_24rec,
        V.F24r = FLUO_24rec - DMSO_24rec,
        V.D144r = DOX_144rec - DMSO_144rec,
        V.F144r = FLUO_144rec - DMSO_144rec,
        levels = mm_r
)

vfit_r <- lmFit(p, mm_r)
vfit_r <- contrasts.fit(vfit_r, contrasts = cm_r)

efit2 <- eBayes(vfit_r)

results = decideTests(efit2)
summary(results)
#inbuilt annotation results rowMeans >0
#         V.D24 V.F24 V.D24r V.F24r V.D144r V.F144r
# Down    4567     0   2083      0     288       0
# NotSig 14521 26445  16339  26445   25296   26445
# Up      7357     0   8023      0     861       0

## have no DE genes detected for 5FU, only DOX


####plot your voom####
voom_plot <- voom(dge_calc, mm_r, plot = TRUE)


```

Now I can go ahead and make toptables for safekeeping and later analysis

```{r Make a TopTable with Your New Data, results='hide',collapse=TRUE}

top.table_V.D24 <- topTable(fit = efit2, coef = "V.D24", number = nrow(dge_calc), adjust.method = "BH", p.value = 1, sort.by = "none")
head(top.table_V.D24)

#saveRDS(top.table_V.D24, "data/top.table_V.D24.RDS")

top.table_V.F24 <- topTable(fit = efit2, coef = "V.F24", number = nrow(dge_calc), adjust.method = "BH", p.value = 1, sort.by = "none")
head(top.table_V.F24)

#saveRDS(top.table_V.F24, "data/top.table_V.F24.RDS")

top.table_V.D24r <- topTable(fit = efit2, coef = "V.D24r", number = nrow(dge_calc), adjust.method = "BH", p.value = 1, sort.by = "none")
head(top.table_V.D24r)

#saveRDS(top.table_V.D24r, "data/top.table_V.D24r.RDS")

top.table_V.F24r <- topTable(fit = efit2, coef = "V.F24r", number = nrow(dge_calc), adjust.method = "BH", p.value = 1, sort.by = "none")
head(top.table_V.F24r)

#saveRDS(top.table_V.F24r, "data/top.table_V.F24r.RDS")

top.table_V.D144r <- topTable(fit = efit2, coef = "V.D144r", number = nrow(dge_calc), adjust.method = "BH", p.value = 1, sort.by = "none")
head(top.table_V.D144r)

#saveRDS(top.table_V.D144r, "data/top.table_V.D144r.RDS")

top.table_V.F144r <- topTable(fit = efit2, coef = "V.F144r", number = nrow(dge_calc), adjust.method = "BH", p.value = 1, sort.by = "none")
head(top.table_V.F144r)

#saveRDS(top.table_V.F144r, "data/top.table_V.F144r.RDS")

```


Volcano Plots
```{r Volcano Plots from Pairwise Gene Analysis, fig.width=8, fig.height=10, collapse=TRUE}

generate_volcano_plot <- function(toptable, title) {
  
  # Add Significance Labels
  toptable$Significance <- "Not Significant"
  toptable$Significance[toptable$logFC > 0 & toptable$adj.P.Val < 0.05] <- "Upregulated"
  toptable$Significance[toptable$logFC < 0 & toptable$adj.P.Val < 0.05] <- "Downregulated"

  # Generate Volcano Plot
  ggplot(toptable, aes(x = logFC, y = -log10(P.Value), color = Significance)) +
    geom_point(alpha = 0.4, size = 2) + 
    scale_color_manual(values = c("Downregulated" = "red", "Upregulated" = "blue", "Not Significant" = "gray")) +
    xlim(-5, 5) +
    labs(title = title, x = "log2 Fold Change", y = "-log10 P-value") +
    theme(legend.position = "none", 
          plot.title = element_text(size = rel(1.5), hjust = 0.5),
          axis.title = element_text(size = rel(1.25))) +
    theme_bw()
}

#now that I've made a function, I can make volcano plots for each of my comparisons (6 total)

volcano_plots <- list(
  "V.D24" = generate_volcano_plot(top.table_V.D24, "Volcano Plot DOX 24hr (adj P-val<0.05)"),
  "V.F24" = generate_volcano_plot(top.table_V.F24, "Volcano Plot 5FU 24hr (adj P-val<0.05)"),
  "V.D24r" = generate_volcano_plot(top.table_V.D24r, "Volcano Plot DOX 24hr Recovery (adj P-val<0.05)"),
  "V.F24r" = generate_volcano_plot(top.table_V.F24r, "Volcano Plot 5FU 24hr Recovery (adj P-val<0.05)"),
  "V.D144r" = generate_volcano_plot(top.table_V.D144r, "Volcano Plot DOX 6d Recovery (adj P-val<0.05)"),
  "V.F144r" = generate_volcano_plot(top.table_V.F144r, "Volcano Plot 5FU 6d Recovery (adj P-val<0.05)")
)

# Display each volcano plot
for (plot_name in names(volcano_plots)) {
  print(volcano_plots[[plot_name]])
}


```

Now that I've looked at these, I'd like to pull out some genes of interest from qPCR

```{r Pull Out Genes of Interest}
fC_Matrix_Full_cpm_filter <- readRDS("data/fC_Matrix_Full_cpm_filter.RDS")
fC_df_filter_cpm <- as.data.frame(fC_Matrix_Full_cpm_filter)
my_data <- rownames_to_column(fC_df_filter_cpm, var = "entrezgene_id")
col_tx_large <- rep(c("#499FBD" ,"#DCACED", "#63666D"), 21)
col_tx_large_2 <- c(rep("#499FBD" , 3), rep("#DCACED", 3), rep("#63666D", 3), 21)


ind_col <- c("#003F5C", "#45AE91",  "#58508D", "#BC4099", "#8B3E9B", "#FF6361", "#FF2362")

tx_col <- c("#499FBD", "#DCACED","#63666D")

time_col <- c("#fbb4b9", "#f768a1", "#ae017e")

##Add columns with more information to each gene I pull out##
ind_names <- c(rep("Ind1", 9), rep("Ind2", 9), rep("Ind3", 9), rep("Ind4", 9), rep("Ind5", 9), rep("Ind6", 9), rep("Ind6REP", 9))
time_names <- c(rep("24", 3), rep("24rec", 3), rep("144rec", 3))
time_names2 <- c("24", "24rec", "144rec")
time_names <- c(rep(time_names, 7))
time_names2 <- c(rep(time_names2, 7))
tx_names <- c("DOX", "FLUO", "DMSO")
tx_names <- c(rep(tx_names, 21))
tx_names2 <- c(rep("DOX", 3), rep("FLUO", 3), rep("DMSO", 3))
tx_names2 <- c(rep(tx_names2, 21))
txtime_names <- c("DOX_24", "FLUO_24", "DMSO_24", "DOX_24rec", "FLUO_24rec", "DMSO_24rec", "DOX_144rec",   "FLUO_144rec",  "DMSO_144rec")
txtime_names <- c(rep(txtime_names, 7))
txtime_names2 <- c("DOX_24", "DOX_24rec", "DOX_144rec", "FLUO_24", "FLUO_24rec", "FLUO_144rec","DMSO_24", "DMSO_24rec", "DMSO_144rec")
txtime_names2 <- c(rep(txtime_names2, 7))


my_data 
my_data_Fluo <- my_data %>% dplyr::select(c("entrezgene_id", "FLUO_24_Ind1", "FLUO_24rec_Ind1", "FLUO_144rec_Ind1", "FLUO_24_Ind2", "FLUO_24rec_Ind2", "FLUO_144rec_Ind2", "FLUO_24_Ind3", "FLUO_24rec_Ind3", "FLUO_144rec_Ind3", "FLUO_24_Ind4", "FLUO_24rec_Ind4", "FLUO_144rec_Ind4", "FLUO_24_Ind5", "FLUO_24rec_Ind5", "FLUO_144rec_Ind5", "FLUO_24_Ind6", "FLUO_24rec_Ind6", "FLUO_144rec_Ind6", "FLUO_24_Ind6REP", "FLUO_24rec_Ind6REP", "FLUO_144rec_Ind6REP"))

###MDM2 - 4193###
MDM2 <- my_data %>% filter(entrezgene_id=="4193")
MDM2_new <- as.data.frame(MDM2) %>% dplyr::select("entrezgene_id", "DOX_24_Ind1", "DOX_24rec_Ind1", "DOX_144rec_Ind1", "FLUO_24_Ind1", "FLUO_24rec_Ind1", "FLUO_144rec_Ind1", "DMSO_24_Ind1", "DMSO_24rec_Ind1", "DMSO_144rec_Ind1","DOX_24_Ind2", "DOX_24rec_Ind2", "DOX_144rec_Ind2", "FLUO_24_Ind2", "FLUO_24rec_Ind2", "FLUO_144rec_Ind2", "DMSO_24_Ind2", "DMSO_24rec_Ind2", "DMSO_144rec_Ind2", "DOX_24_Ind3", "DOX_24rec_Ind3", "DOX_144rec_Ind3", "FLUO_24_Ind3", "FLUO_24rec_Ind3", "FLUO_144rec_Ind3", "DMSO_24_Ind3", "DMSO_24rec_Ind3", "DMSO_144rec_Ind3", "DOX_24_Ind4", "DOX_24rec_Ind4", "DOX_144rec_Ind4", "FLUO_24_Ind4", "FLUO_24rec_Ind4", "FLUO_144rec_Ind4", "DMSO_24_Ind4", "DMSO_24rec_Ind4", "DMSO_144rec_Ind4", "DOX_24_Ind5", "DOX_24rec_Ind5", "DOX_144rec_Ind5", "FLUO_24_Ind5", "FLUO_24rec_Ind5", "FLUO_144rec_Ind5", "DMSO_24_Ind5", "DMSO_24rec_Ind5", "DMSO_144rec_Ind5", "DOX_24_Ind6", "DOX_24rec_Ind6", "DOX_144rec_Ind6", "FLUO_24_Ind6", "FLUO_24rec_Ind6", "FLUO_144rec_Ind6", "DMSO_24_Ind6", "DMSO_24rec_Ind6", "DMSO_144rec_Ind6", "DOX_24_Ind6REP", "DOX_24rec_Ind6REP", "DOX_144rec_Ind6REP", "FLUO_24_Ind6REP", "FLUO_24rec_Ind6REP", "FLUO_144rec_Ind6REP", "DMSO_24_Ind6REP", "DMSO_24rec_Ind6REP", "DMSO_144rec_Ind6REP")
MDM2_melt <- melt(MDM2, variable.name = "sample")
MDM2_melt_new <- melt(MDM2_new, variable.name = "sample")

MDM2_melt_df <- data.frame(tx = factor(tx_names, levels = unique(tx_names)),
                               ind = factor(ind_names, levels = unique(ind_names)),
                               txtime = factor(txtime_names, levels = unique(txtime_names)),
                               time = factor(time_names, levels = unique(time_names)))
MDM2_melt_df2 <- data.frame(tx = factor(tx_names2, levels = unique(tx_names2)),
                               ind = factor(ind_names, levels = unique(ind_names)),
                               txtime = factor(txtime_names2, levels = unique(txtime_names2)),
                               time = factor(time_names2, levels = unique(time_names2)))
MDM2_melt_df_all <- cbind(MDM2_melt, MDM2_melt_df)
MDM2_melt_df_all2 <- cbind(MDM2_melt_new, MDM2_melt_df2)

ggplot(MDM2_melt, aes(x=value, y=sample, fill = sample))+
  ggtitle("MDM2")+
    geom_bar(stat = "identity", width = 0.8)+
  theme(legend.position = "none")+
  scale_fill_manual(values = col_tx_large)+
    xlab("log2cpm")+
  ylab("Conditions")
###FLUO ONLY####
MDM2_fluo <- my_data_Fluo %>% filter(entrezgene_id=="4193")
MDM2_melt_fluo <- melt(MDM2_fluo, variable.name = "sample")
ggplot(MDM2_melt_fluo, aes(x=value, y=sample, fill = sample))+
  ggtitle("MDM2")+
    geom_bar(stat = "identity", width = 0.8)+
  theme(legend.position = "none")+
  scale_fill_manual(values = col_tx_large)+
    xlab("log2cpm")+
  ylab("Conditions")


####CDKN1A - 1026####
CDKN1A <- my_data %>% filter(entrezgene_id=="1026")
CDKN1A_new <- as.data.frame(CDKN1A) %>% dplyr::select("entrezgene_id", "DOX_24_Ind1", "DOX_24rec_Ind1", "DOX_144rec_Ind1", "FLUO_24_Ind1", "FLUO_24rec_Ind1", "FLUO_144rec_Ind1", "DMSO_24_Ind1", "DMSO_24rec_Ind1", "DMSO_144rec_Ind1","DOX_24_Ind2", "DOX_24rec_Ind2", "DOX_144rec_Ind2", "FLUO_24_Ind2", "FLUO_24rec_Ind2", "FLUO_144rec_Ind2", "DMSO_24_Ind2", "DMSO_24rec_Ind2", "DMSO_144rec_Ind2", "DOX_24_Ind3", "DOX_24rec_Ind3", "DOX_144rec_Ind3", "FLUO_24_Ind3", "FLUO_24rec_Ind3", "FLUO_144rec_Ind3", "DMSO_24_Ind3", "DMSO_24rec_Ind3", "DMSO_144rec_Ind3", "DOX_24_Ind4", "DOX_24rec_Ind4", "DOX_144rec_Ind4", "FLUO_24_Ind4", "FLUO_24rec_Ind4", "FLUO_144rec_Ind4", "DMSO_24_Ind4", "DMSO_24rec_Ind4", "DMSO_144rec_Ind4", "DOX_24_Ind5", "DOX_24rec_Ind5", "DOX_144rec_Ind5", "FLUO_24_Ind5", "FLUO_24rec_Ind5", "FLUO_144rec_Ind5", "DMSO_24_Ind5", "DMSO_24rec_Ind5", "DMSO_144rec_Ind5", "DOX_24_Ind6", "DOX_24rec_Ind6", "DOX_144rec_Ind6", "FLUO_24_Ind6", "FLUO_24rec_Ind6", "FLUO_144rec_Ind6", "DMSO_24_Ind6", "DMSO_24rec_Ind6", "DMSO_144rec_Ind6", "DOX_24_Ind6REP", "DOX_24rec_Ind6REP", "DOX_144rec_Ind6REP", "FLUO_24_Ind6REP", "FLUO_24rec_Ind6REP", "FLUO_144rec_Ind6REP", "DMSO_24_Ind6REP", "DMSO_24rec_Ind6REP", "DMSO_144rec_Ind6REP")
CDKN1A_melt <- melt(CDKN1A, variable.name = "sample")
CDKN1A_melt_new <- melt(CDKN1A_new, variable.name = "sample")

CDKN1A_melt_df <- data.frame(tx = factor(tx_names, levels = unique(tx_names)),
                               ind = factor(ind_names, levels = unique(ind_names)),
                               txtime = factor(txtime_names, levels = unique(txtime_names)),
                               time = factor(time_names, levels = unique(time_names)))
CDKN1A_melt_df2 <- data.frame(tx = factor(tx_names2, levels = unique(tx_names2)),
                               ind = factor(ind_names, levels = unique(ind_names)),
                               txtime = factor(txtime_names2, levels = unique(txtime_names2)),
                               time = factor(time_names2, levels = unique(time_names2)))
CDKN1A_melt_df_all <- cbind(CDKN1A_melt, CDKN1A_melt_df)
CDKN1A_melt_df_all2 <- cbind(CDKN1A_melt_new, CDKN1A_melt_df2)

ggplot(CDKN1A_melt, aes(x=value, y=sample, fill = sample))+
  ggtitle("CDKN1A")+
    geom_bar(stat = "identity", width = 0.8)+
  theme(legend.position = "none")+
  scale_fill_manual(values = col_tx_large)+
    xlab("log2cpm")+
  ylab("Conditions")


####SIRT1 - 23411####
SIRT1 <- my_data %>% filter(entrezgene_id=="23411")
SIRT1_new <- as.data.frame(SIRT1) %>% dplyr::select("entrezgene_id", "DOX_24_Ind1", "DOX_24rec_Ind1", "DOX_144rec_Ind1", "FLUO_24_Ind1", "FLUO_24rec_Ind1", "FLUO_144rec_Ind1", "DMSO_24_Ind1", "DMSO_24rec_Ind1", "DMSO_144rec_Ind1","DOX_24_Ind2", "DOX_24rec_Ind2", "DOX_144rec_Ind2", "FLUO_24_Ind2", "FLUO_24rec_Ind2", "FLUO_144rec_Ind2", "DMSO_24_Ind2", "DMSO_24rec_Ind2", "DMSO_144rec_Ind2", "DOX_24_Ind3", "DOX_24rec_Ind3", "DOX_144rec_Ind3", "FLUO_24_Ind3", "FLUO_24rec_Ind3", "FLUO_144rec_Ind3", "DMSO_24_Ind3", "DMSO_24rec_Ind3", "DMSO_144rec_Ind3", "DOX_24_Ind4", "DOX_24rec_Ind4", "DOX_144rec_Ind4", "FLUO_24_Ind4", "FLUO_24rec_Ind4", "FLUO_144rec_Ind4", "DMSO_24_Ind4", "DMSO_24rec_Ind4", "DMSO_144rec_Ind4", "DOX_24_Ind5", "DOX_24rec_Ind5", "DOX_144rec_Ind5", "FLUO_24_Ind5", "FLUO_24rec_Ind5", "FLUO_144rec_Ind5", "DMSO_24_Ind5", "DMSO_24rec_Ind5", "DMSO_144rec_Ind5", "DOX_24_Ind6", "DOX_24rec_Ind6", "DOX_144rec_Ind6", "FLUO_24_Ind6", "FLUO_24rec_Ind6", "FLUO_144rec_Ind6", "DMSO_24_Ind6", "DMSO_24rec_Ind6", "DMSO_144rec_Ind6", "DOX_24_Ind6REP", "DOX_24rec_Ind6REP", "DOX_144rec_Ind6REP", "FLUO_24_Ind6REP", "FLUO_24rec_Ind6REP", "FLUO_144rec_Ind6REP", "DMSO_24_Ind6REP", "DMSO_24rec_Ind6REP", "DMSO_144rec_Ind6REP")
SIRT1_melt <- melt(SIRT1, variable.name = "sample")
SIRT1_melt_new <- melt(SIRT1_new, variable.name = "sample")

SIRT1_melt_df <- data.frame(tx = factor(tx_names, levels = unique(tx_names)),
                               ind = factor(ind_names, levels = unique(ind_names)),
                               txtime = factor(txtime_names, levels = unique(txtime_names)),
                               time = factor(time_names, levels = unique(time_names)))
SIRT1_melt_df2 <- data.frame(tx = factor(tx_names2, levels = unique(tx_names2)),
                               ind = factor(ind_names, levels = unique(ind_names)),
                               txtime = factor(txtime_names2, levels = unique(txtime_names2)),
                               time = factor(time_names2, levels = unique(time_names2)))
SIRT1_melt_df_all <- cbind(SIRT1_melt, SIRT1_melt_df)
SIRT1_melt_df_all2 <- cbind(SIRT1_melt_new, SIRT1_melt_df2)

SIRT1_melt <- melt(SIRT1, variable.name = "sample")
ggplot(SIRT1_melt, aes(x=value, y=sample, fill = sample))+
  ggtitle("SIRT1")+
    geom_bar(stat = "identity", width = 0.8)+
  theme(legend.position = "none")+
  scale_fill_manual(values = col_tx_large)+
    xlab("log2cpm")+
  ylab("Conditions")


####Pull out genes and make them into boxplots with points for each individual####
####MDM2####
MDM2_melt_df_all2 %>% ggplot(aes(x = txtime, y = value))+
  geom_boxplot(aes(fill = tx))+
  geom_point(aes(color = ind)) +
  labs(title = "MDM2")+
  theme_bw(base_size = 16)+
  scale_fill_manual(values = c(tx_col))+
  scale_color_manual(values = c(ind_col))+
  xlab("Conditions")+
  ylab("log2cpm")

####CDKN1A####
CDKN1A_melt_df_all2 %>% ggplot(aes(x = txtime, y = value))+
  geom_boxplot(aes(fill = tx))+
  geom_point(aes(color = ind)) +
  labs(title = "CDKN1A")+
  theme_bw(base_size = 16)+
  scale_fill_manual(values = c(tx_col))+
  scale_color_manual(values = c(ind_col))+
  xlab("Conditions")+
  ylab("log2cpm")


####SIRT1####
SIRT1_melt_df_all2 %>% ggplot(aes(x = txtime, y = value))+
  geom_boxplot(aes(fill = tx))+
  geom_point(aes(color = ind)) +
  labs(title = "SIRT1")+
  theme_bw(base_size = 16)+
  scale_fill_manual(values = c(tx_col))+
  scale_color_manual(values = c(ind_col))+
  xlab("Conditions")+
  ylab("log2cpm")

```

Now that I've pulled out some select genes for each condition - let's look at some typically expressed cardiac genes to check whether they are present in this dataset

```{r Typical genes expressed in iPSC-CMs}
fC_df_filter_cpm <- as.data.frame(fC_Matrix_Full_cpm_filter)
my_data <- rownames_to_column(fC_df_filter_cpm, var = "entrezgene_id")
###now let's pull some classic cardiac genes expressed in iPSC-CMs###
genecardiccheck <- c("MYH7", "TNNT2","MYH6","ACTN2","BMP3","TNNI3","RYR2","CACNA1C","KCNQ1", "HCN1", "ADRB1", "ADRB2")

# ensembl <- useMart("ensembl", dataset="hsapiens_gene_ensembl")
# saveRDS(ensembl, "data/ensembl_backup.RDS")
ensembl <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/ensembl_backup.RDS")
my_chr <- c(1:22, 'M', 'X', 'Y')  ## creates a filter for each database

my_attributes <- c('entrezgene_id', 'ensembl_gene_id', 'hgnc_symbol')

heartgenes <- getBM(attributes=my_attributes,filters ='hgnc_symbol',
                values = genecardiccheck, mart = ensembl)
write.csv(heartgenes, "data/heartgenes.csv")
heartgenes <-read.csv("data/heartgenes.csv")

fungraph <- as.data.frame(fC_df_filter_cpm[rownames(fC_df_filter_cpm) %in% heartgenes$entrezgene_id,])


fungraph %>% 
  rownames_to_column("entrezgene_id") %>% 
  pivot_longer(-entrezgene_id, names_to = "samples",values_to = "counts") %>% 
  mutate(gene = case_match(entrezgene_id,"88"~"ACTN2","153"~"ADRB1",
  "154"~"ADRB2","651"~"BMP3","775"~"CACNA1C", "100874369"~"CACNA1C","348980"~"HCN1",
                           "3784"~"KCNQ1", "4624"~"MYH6","4625"~"MYH7","6262"~"RYR2",
                           "7137"~"TNNI3","7139"~"TNNT2",.default = entrezgene_id)) %>% 
  ggplot(., aes(x=reorder(gene,counts,decreasing=TRUE), y=counts))+
  geom_boxplot()+
  ggtitle(expression("Expression of typical cardiac tissue genes"))+
  xlab("")+
  ylab(expression("log"[2]~"cpm"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size =10, color = "black", angle = 0),
        strip.text.y = element_text(color = "white"))


```


Now that I've gone through and figured out the basics of DE - let's remove unwanted variation using ruv
This uses my replicates to figure out covariates in the data and remove variation occurring due to batch effects or other effects
We're seeing a batch effect from RNA extraction (all RNAseq library prep done in a single batch) occurring here in PCA and cor. heatmaps rather than individuals clustering together.

```{r RUVs Correction Data Setup}

filt_gene_list <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/filt_gene_list.RDS")

RUV_filt_counts <- fC_Matrix_Full %>% 
  as.data.frame() %>% 
  dplyr::filter(., row.names(.)%in% filt_gene_list)

#add in the annotation files
ind_num <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/ind_num.RDS")
annot <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/annot.RDS")


#  counts need to be integer values and in a numeric matrix
# note: the log transformation needs to be accounted for in the isLog argument in RUVs function.
counts <- as.matrix(RUV_filt_counts)

# Create a DataFrame for the phenoData
phenoData <- DataFrame(annot)

# Now create the RangedSummarizedExperiment necessary for RUVs input
# looks like it did need both the phenodata and the counts.
set <- SummarizedExperiment(assays =  counts, metadata = phenoData)

# Generate a background matrix
# The column "Cond" holds the comparisons that you actually want to make. DOX_24, DMSO_24,5FU_24, DOX_3,etc.
scIdx <-RUVSeq::makeGroups(phenoData$Tx_Time)
scIdx

#now I've made all of the data I need for this - they are located in each section for k values

#DO NOT USE THESE COUNTS FOR LINEAR MODELING

#colors for all of the plots
fill_col_ind <- c("#66C2A5", "#FC8D62", "#1F78B4", "#E78AC3", "#A6D854", "#FFD92A", "#8B3E9B")

fill_col_ind_dark <- c("#003F5C", "#45AE91",  "#58508D", "#BC4099", "#8B3E9B", "#FF6361", "#FF2362")

fill_col_tx <- c("#63666D", "#499FBD", "#DCACED")

fill_col_txtime <- c("#003F5C", "#45AE91",  "#58508D", "#BC4099", "#8B3E9B", "#FF6361", "#FF2362", "#A6D854", "#FC8D62")

# before ruv
prcomp_res <- prcomp(t(counts), scale. = FALSE, center = TRUE)
ggplot2::autoplot(prcomp_res, data = annot, colour = "Tx_Time", size =4)+
  theme_bw()+
  scale_color_manual(values = c(fill_col_txtime))+
  ggrepel::geom_text_repel(label= ind_num)+
  ggtitle("No RUV")



####new PCA plots no correction####
#PCA plots for each value of k attached in each section
prcomp_res <- prcomp(t(counts), scale. = FALSE, center = TRUE)
annot_prcomp_res <- prcomp_res$x %>% cbind(., annot)

# annot_prcomp_res %>% ggplot(., aes(x=PC1, y=PC2, size = 10)) +
#   geom_point(aes(color = Ind, shape = Time, fill = Tx)) +
#                        scale_shape_manual(values = c(21, 22, 24)) +
#   scale_fill_manual(values =  fill_col_tx)+
#   scale_color_manual(values = c(fill_col_ind_dark))+
#   guides(fill=guide_legend(override.aes=list(shape=21)))+
#   guides(color=guide_legend(override.aes=list(shape=21)))+
#   guides(fill=guide_legend(override.aes=list(shape=21,fill=fill_col_tx,color=fill_col_tx)))+
#   ggtitle("no RUVs")

# annot_prcomp_res %>% ggplot(., aes(x=PC1, y=PC2, size =10)) +
#   geom_point(aes(color = Tx_Time))+
#   ggrepel::geom_text_repel(label=ind_num)+
#   theme_bw()+
#   scale_color_manual(values = c(fill_col_txtime))+
#   ggtitle("no RUVs Correction")
  

group_2 <- rep(c("DOX_24","FLUO_24",
                                "DMSO_24",
                                "DOX_24rec",
                                "FLUO_24rec",
                                "DMSO_24rec",
                                "DOX_144rec",
                                "FLUO_144rec",
                                "DMSO_144rec"), 7)


dge1 <- DGEList.data.frame(counts = fC_Matrix_Full, group = group_2, genes = row.names(fC_Matrix_Full))

#calculate the normalization factors with method TMM
dge1_calc <- calcNormFactors(dge1, method = "TMM")

#Pull out factors
snames1 <- data.frame("samples" = colnames(dge1_calc)) %>% separate_wider_delim(., cols = samples, names = c("Treatment", "Time", "Individual"), delim = "_", cols_remove = FALSE)

snames1_ind <- snames1$Individual

#noRUV toptables
top.table_V.D24
top.table_V.D24r
top.table_V.D144r

top.table_V.F24
top.table_V.F24r
top.table_V.F144r


```


```{r RUVs k1 Data}

#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set <- RUVSeq::RUVs(x = counts, k =1, scIdx = scIdx, isLog = FALSE)

#get the ruv weights to put into the linear model. n weights = k.
#k=1
RUV_df <- set$W %>% as.data.frame()
RUV_df$Names <- rownames(RUV_df)


#Check that the names match
#k=1
RUV_df_rm <- RUV_df[RUV_df$Names %in% annot$samples, ] 
RUV_1 <-  RUV_df_rm$W_1

# after ruv k=1
#prcomp_res <- prcomp(t(set$normalizedCounts), scale. = FALSE, center = TRUE)
  #theme_bw()+
  #ggtitle("RUV Corrected k=1")

#PCA checks
#k=1
prcomp_res_1 <- prcomp(t(set$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_1 <- prcomp_res_1$x %>% cbind(., annot)

ggplot2::autoplot(prcomp_res_1, data = annot, colour = "Tx_Time", size =4)+
  theme_bw()+
  scale_color_manual(values = c(fill_col_txtime))+
  ggrepel::geom_text_repel(label= ind_num)+
  ggtitle("RUVs Correction k=1")

# annot_prcomp_res_1 %>% ggplot(., aes(x=PC1, y=PC2, size = 10)) +
#   geom_point(aes(color = Ind, shape = Time, fill = Tx)) +
#                        scale_shape_manual(values = c(21, 22, 24)) +
#   scale_fill_manual(values =  fill_col_tx)+
#   scale_color_manual(values = c(fill_col_ind_dark))+
#   guides(fill=guide_legend(override.aes=list(shape=21)))+
#   guides(color=guide_legend(override.aes=list(shape=21)))+
#   guides(fill=guide_legend(override.aes=list(shape=21,fill=fill_col_tx,color=fill_col_tx)))+
#   ggtitle("RUVs k=1")

# annot_prcomp_res_1 %>% ggplot(., aes(x=PC1, y=PC2, size =10)) +
#   geom_point(aes(color = Tx, shape = Time))+
#   ggrepel::geom_text_repel(label=ind_num)+
#   theme_bw()+
#   scale_color_manual(values = c(fill_col_tx))+
#   ggtitle("RUVs k=1")

#k=1
annot$samples == RUV_df_rm$Names
annot$RUV_1 <- RUV_df_rm$W_1

#Create my model matrix
#k=1
mm_r1 <- model.matrix(~0 + group_2 + RUV_1, data = annot)

p1 <- voom(dge1_calc$counts, mm_r1, plot = TRUE)

corfit1 <- duplicateCorrelation(p1, mm_r1, block = snames1_ind)

v1 <- voom(dge1_calc$counts, mm_r1, block = snames1_ind, correlation = corfit1$consensus)

fit1 <- lmFit(v1, mm_r1, block = snames1_ind, correlation = corfit1$consensus)

#k=1
mm_r1_names <- str_replace(string = colnames(mm_r1), pattern = "group_2", replacement = "")
design <- model.matrix(~ group_2 + RUV_1 , annot)
colnames(mm_r1) <- mm_r1_names

#k=1
cm_r1 <- makeContrasts(
        V.D24 = DOX_24 - DMSO_24,
        V.F24 = FLUO_24 - DMSO_24,
        V.D24r = DOX_24rec - DMSO_24rec,
        V.F24r = FLUO_24rec - DMSO_24rec,
        V.D144r = DOX_144rec - DMSO_144rec,
        V.F144r = FLUO_144rec - DMSO_144rec,
        RUV_1_24 = RUV_1 - DMSO_24,
        RUV_1_24r = RUV_1 - DMSO_24rec,
        RUV_1_144r = RUV_1 - DMSO_144rec,
        levels = mm_r1
)

#k=1
vfit_r1 <- lmFit(p1, mm_r1)
vfit_r1 <- contrasts.fit(vfit_r1, contrasts = cm_r1)

#k=1
efit1 <- eBayes(vfit_r1)

#k=1
results1 = decideTests(efit1)
summary(results1)

#k=1
toptable_Dupcor_DOX <- topTable(efit1, coef = "V.D24", number = nrow(dge1_calc$counts), p.value = 1)
toptable_Dupcor_DOXrec <- topTable(efit1, coef = "V.D24r", number = nrow(dge1_calc$counts), p.value = 1)
toptable_Dupcor_DOX144 <- topTable(efit1, coef = "V.D144r", number = nrow(dge1_calc$counts), p.value = 1)
#k=1 plots
toptable_Dupcor_DOX$logFC %>% hist(, main= "RUVs k=1 DOX 24hr Toptable")
toptable_Dupcor_DOXrec$logFC %>% hist(, main = "RUVs k=1 DOX 24Rec Toptable")
toptable_Dupcor_DOX144$logFC %>% hist(, main = "RUVs k=1 DOX 144Rec Toptable")

```

```{r RUVs k2 Data}
#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set2 <- RUVSeq::RUVs(x = counts, k =2, scIdx = scIdx, isLog = FALSE)

#get the ruv weights to put into the linear model. n weights = k.
#k=2
RUV_df2 <- set2$W %>% as.data.frame()
RUV_df2$Names <- rownames(RUV_df2)

#make sure the names match
#k=2
RUV_df_rm2 <- RUV_df2[RUV_df2$Names %in% annot$samples, ] 
RUV_2 <-  RUV_df_rm2$W_2

# after ruv k=2
prcomp_res_2 <- prcomp(t(set2$normalizedCounts), scale. = FALSE, center = TRUE)
ggplot2::autoplot(prcomp_res_2, data = annot, colour = "Tx_Time", size =4)+
  theme_bw()+
  scale_color_manual(values = c(fill_col_txtime))+
  ggrepel::geom_text_repel(label= ind_num)+
  ggtitle("RUV Corrected k=2")

#k=2
# prcomp_res_2 <- prcomp(t(set2$normalizedCounts), scale. = FALSE, center = TRUE)
# annot_prcomp_res_2 <- prcomp_res_2$x %>% cbind(., annot)
# 
# annot_prcomp_res_2 %>% ggplot(., aes(x=PC1, y=PC2, size = 10)) +
#   geom_point(aes(color = Ind, shape = Time, fill = Tx)) +
#                        scale_shape_manual(values = c(21, 22, 24)) +
#   scale_fill_manual(values =  fill_col_tx)+
#   scale_color_manual(values = c(fill_col_ind_dark))+
#   guides(fill=guide_legend(override.aes=list(shape=21)))+
#   guides(color=guide_legend(override.aes=list(shape=21)))+
#   guides(fill=guide_legend(override.aes=list(shape=21,fill=fill_col_tx,color=fill_col_tx)))+
#   ggtitle("RUVs k=2")

#k=2
annot$samples == RUV_df_rm2$Names
annot$RUV_2 <- RUV_df_rm2$W_2

#k=2
mm_r2 <- model.matrix(~0 + group_2 + RUV_2, data = annot)

p2 <- voom(dge1_calc$counts, mm_r2, plot = TRUE)

corfit2 <- duplicateCorrelation(p2, mm_r2, block = snames1_ind)

v2 <- voom(dge1_calc$counts, mm_r2, block = snames1_ind, correlation = corfit2$consensus)

fit2 <- lmFit(v2, mm_r2, block = snames1_ind, correlation = corfit2$consensus)

#k=2
mm_r2_names <- str_replace(string = colnames(mm_r2), pattern = "group_2", replacement = "")
design <- model.matrix(~ group_2 + RUV_2 , annot)
colnames(mm_r2) <- mm_r2_names

#k=2
cm_r2 <- makeContrasts(
        V.D24 = DOX_24 - DMSO_24,
        V.F24 = FLUO_24 - DMSO_24,
        V.D24r = DOX_24rec - DMSO_24rec,
        V.F24r = FLUO_24rec - DMSO_24rec,
        V.D144r = DOX_144rec - DMSO_144rec,
        V.F144r = FLUO_144rec - DMSO_144rec,
        RUV_2_24 = RUV_2 - DMSO_24,
        RUV_2_24r = RUV_2 - DMSO_24rec,
        RUV_2_144r = RUV_2 - DMSO_144rec,
        levels = mm_r2
)

#k=2
vfit_r2 <- lmFit(p2, mm_r2)
vfit_r2 <- contrasts.fit(vfit_r2, contrasts = cm_r2)

#k=2
efit2 <- eBayes(vfit_r2)

#k=2
results2 = decideTests(efit2)
summary(results2)

#k=2
toptable2_Dupcor_DOX <- topTable(efit2, coef = "V.D24", number = nrow(dge1_calc$counts), p.value = 1)
toptable2_Dupcor_DOXrec <- topTable(efit2, coef = "V.D24r", number = nrow(dge1_calc$counts), p.value = 1)
toptable2_Dupcor_DOX144 <- topTable(efit2, coef = "V.D144r", number = nrow(dge1_calc$counts), p.value = 1)
#k=2 plots
toptable2_Dupcor_DOX$logFC %>% hist(, main= "RUVs k=2 DOX 24hr Toptable")
toptable2_Dupcor_DOXrec$logFC %>% hist(, main = "RUVs k=2 DOX 24Rec Toptable")
toptable2_Dupcor_DOX144$logFC %>% hist(, main = "RUVs k=2 DOX 144Rec Toptable")

```

```{r RUVs k3 Data}

#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set3 <- RUVSeq::RUVs(x = counts, k =3, scIdx = scIdx, isLog = FALSE)

#get the ruv weights to put into the linear model. n weights = k.
#k=3
RUV_df3 <- set3$W %>% as.data.frame()
RUV_df3$Names <- rownames(RUV_df3)

#make sure the names match
#k=3
RUV_df_rm3 <- RUV_df3[RUV_df3$Names %in% annot$samples, ] 
RUV_3 <-  RUV_df_rm3$W_3

# after ruv k=3
# prcomp_res <- prcomp(t(set3$normalizedCounts), scale. = FALSE, center = TRUE)
# ggplot2::autoplot(prcomp_res, data = annot, colour = "Tx_Time", shape = "Ind", size =4)+
#   theme_bw()+
#   ggtitle("RUV Corrected k=3")

#k=3
prcomp_res_3 <- prcomp(t(set3$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_3 <- prcomp_res_3$x %>% cbind(., annot)

ggplot2::autoplot(prcomp_res_3, data = annot, colour = "Tx_Time", size =4)+
  theme_bw()+
  scale_color_manual(values = c(fill_col_txtime))+
  ggrepel::geom_text_repel(label= ind_num)+
  ggtitle("RUVs Correction k=3")

# annot_prcomp_res_3 %>% ggplot(., aes(x=PC1, y=PC2, size = 10)) +
#   geom_point(aes(color = Ind, shape = Time, fill = Tx)) +
#                        scale_shape_manual(values = c(21, 22, 24)) +
#   scale_fill_manual(values =  fill_col_tx)+
#   scale_color_manual(values = c(fill_col_ind_dark))+
#   guides(fill=guide_legend(override.aes=list(shape=21)))+
#   guides(color=guide_legend(override.aes=list(shape=21)))+
#   guides(fill=guide_legend(override.aes=list(shape=21,fill=fill_col_tx,color=fill_col_tx)))+
#   ggtitle("RUVs k=3")


#k=3
annot$samples == RUV_df_rm3$Names
annot$RUV_3 <- RUV_df_rm3$W_3

#k=3
mm_r3 <- model.matrix(~0 + group_2 + RUV_3, data = annot)

p3 <- voom(dge1_calc$counts, mm_r3, plot = TRUE)

corfit3 <- duplicateCorrelation(p3, mm_r3, block = snames1_ind)

v3 <- voom(dge1_calc$counts, mm_r3, block = snames1_ind, correlation = corfit3$consensus)

fit3 <- lmFit(v3, mm_r3, block = snames1_ind, correlation = corfit3$consensus)

#k=3
mm_r3_names <- str_replace(string = colnames(mm_r3), pattern = "group_2", replacement = "")
design <- model.matrix(~ group_2 + RUV_3 , annot)
colnames(mm_r3) <- mm_r3_names

#k=3
cm_r3 <- makeContrasts(
        V.D24 = DOX_24 - DMSO_24,
        V.F24 = FLUO_24 - DMSO_24,
        V.D24r = DOX_24rec - DMSO_24rec,
        V.F24r = FLUO_24rec - DMSO_24rec,
        V.D144r = DOX_144rec - DMSO_144rec,
        V.F144r = FLUO_144rec - DMSO_144rec,
        RUV_3_24 = RUV_3 - DMSO_24,
        RUV_3_24r = RUV_3 - DMSO_24rec,
        RUV_3_144r = RUV_3 - DMSO_144rec,
        levels = mm_r3
)


#k=3
vfit_r3 <- lmFit(p3, mm_r3)
vfit_r3 <- contrasts.fit(vfit_r3, contrasts = cm_r3)

#k=3
efit3 <- eBayes(vfit_r3)

#k=3
results3 = decideTests(efit3)
summary(results3)

#k=3
toptable3_Dupcor_DOX <- topTable(efit3, coef = "V.D24", number = nrow(dge1_calc$counts), p.value = 1)
toptable3_Dupcor_DOXrec <- topTable(efit3, coef = "V.D24r", number = nrow(dge1_calc$counts), p.value = 1)
toptable3_Dupcor_DOX144 <- topTable(efit3, coef = "V.D144r", number = nrow(dge1_calc$counts), p.value = 1)
#k=3 plots
toptable3_Dupcor_DOX$logFC %>% hist(, main= "RUVs k=3 DOX 24hr Toptable")
toptable3_Dupcor_DOXrec$logFC %>% hist(, main = "RUVs k=3 DOX 24Rec Toptable")
toptable3_Dupcor_DOX144$logFC %>% hist(, main = "RUVs k=3 DOX 144Rec Toptable")

```


```{r RUVs k4 Data}

#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set4 <- RUVSeq::RUVs(x = counts, k =4, scIdx = scIdx, isLog = FALSE)

#get the ruv weights to put into the linear model. n weights = k.
#k=4
RUV_df4 <- set4$W %>% as.data.frame()
RUV_df4$Names <- rownames(RUV_df4)

#make sure that the names match
#k=4
RUV_df_rm4 <- RUV_df4[RUV_df4$Names %in% annot$samples, ] 
RUV_4 <-  RUV_df_rm4$W_4

#after ruv k=4
# prcomp_res <- prcomp(t(set4$normalizedCounts), scale. = FALSE, center = TRUE)
# ggplot2::autoplot(prcomp_res, data = annot, colour = "Tx_Time", shape = "Ind", size =4)+
#   theme_bw()+
#   ggtitle("RUV Corrected k=4")

#k=4 PCA
prcomp_res_4 <- prcomp(t(set4$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_4 <- prcomp_res_4$x %>% cbind(., annot)

ggplot2::autoplot(prcomp_res_4, data = annot, colour = "Tx_Time", size =4)+
  theme_bw()+
  scale_color_manual(values = c(fill_col_txtime))+
  ggrepel::geom_text_repel(label= ind_num)+
  ggtitle("RUVs Correction k=4")

# annot_prcomp_res_4 %>% ggplot(., aes(x=PC1, y=PC2, size = 10)) +
#   geom_point(aes(color = Ind, shape = Time, fill = Tx)) +
#                        scale_shape_manual(values = c(21, 22, 24)) +
#   scale_fill_manual(values =  fill_col_tx)+
#   scale_color_manual(values = c(fill_col_ind_dark))+
#   guides(fill=guide_legend(override.aes=list(shape=21)))+
#   guides(color=guide_legend(override.aes=list(shape=21)))+
#   guides(fill=guide_legend(override.aes=list(shape=21,fill=fill_col_tx,color=fill_col_tx)))+
#   ggtitle("RUVs k=4")


#k=4
annot$samples == RUV_df_rm4$Names
annot$RUV_4 <- RUV_df_rm4$W_4

#k=4
mm_r4 <- model.matrix(~0 + group_2 + RUV_4, data = annot)

p4 <- voom(dge1_calc$counts, mm_r4, plot = TRUE)

corfit4 <- duplicateCorrelation(p4, mm_r4, block = snames1_ind)

v4 <- voom(dge1_calc$counts, mm_r4, block = snames1_ind, correlation = corfit4$consensus)

fit4 <- lmFit(v4, mm_r4, block = snames1_ind, correlation = corfit4$consensus)

#k=4
mm_r4_names <- str_replace(string = colnames(mm_r4), pattern = "group_2", replacement = "")
design <- model.matrix(~ group_2 + RUV_4 , annot)
colnames(mm_r4) <- mm_r4_names

#k=4
cm_r4 <- makeContrasts(
        V.D24 = DOX_24 - DMSO_24,
        V.F24 = FLUO_24 - DMSO_24,
        V.D24r = DOX_24rec - DMSO_24rec,
        V.F24r = FLUO_24rec - DMSO_24rec,
        V.D144r = DOX_144rec - DMSO_144rec,
        V.F144r = FLUO_144rec - DMSO_144rec,
        RUV_4_24 = RUV_4 - DMSO_24,
        RUV_4_24r = RUV_4 - DMSO_24rec,
        RUV_4_144r = RUV_4 - DMSO_144rec,
        levels = mm_r4
)

#k=4
vfit_r4 <- lmFit(p4, mm_r4)
vfit_r4 <- contrasts.fit(vfit_r4, contrasts = cm_r4)

#k=4
efit4 <- eBayes(vfit_r4)

#k=4
results4 = decideTests(efit4)
summary(results4)

#k=4
toptable4_Dupcor_DOX <- topTable(efit4, coef = "V.D24", number = nrow(dge1_calc$counts), p.value = 1)
toptable4_Dupcor_DOXrec <- topTable(efit4, coef = "V.D24r", number = nrow(dge1_calc$counts), p.value = 1)
toptable4_Dupcor_DOX144 <- topTable(efit4, coef = "V.D144r", number = nrow(dge1_calc$counts), p.value = 1)
#k=4 plots
toptable4_Dupcor_DOX$logFC %>% hist(, main= "RUVs k=4 DOX 24hr Toptable")
toptable4_Dupcor_DOXrec$logFC %>% hist(, main = "RUVs k=4 DOX 24Rec Toptable")
toptable4_Dupcor_DOX144$logFC %>% hist(, main = "RUVs k=4 DOX 144Rec Toptable")

```


```{r RUVs k5 Data}
#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set5 <- RUVSeq::RUVs(x = counts, k =5, scIdx = scIdx, isLog = TRUE)

#get the ruv weights to put into the linear model. n weights = k.
#k=5
RUV_df5 <- set5$W %>% as.data.frame()
RUV_df5$Names <- rownames(RUV_df5)

#check that the names match
#k=5
RUV_df_rm5 <- RUV_df5[RUV_df5$Names %in% annot$samples, ] 
RUV_5 <-  RUV_df_rm5$W_5

#ruv k=5 PCA
# prcomp_res_5 <- prcomp(t(set5$normalizedCounts), scale. = FALSE, center = TRUE)
# ggplot2::autoplot(prcomp_res_5, data = annot, colour = "Tx_Time", shape = "Ind", size =4)+
#   theme_bw()+
#   ggtitle("RUV Corrected k=5")

#k=5
prcomp_res_5 <- prcomp(t(set5$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_5 <- prcomp_res_5$x %>% cbind(., annot)

ggplot2::autoplot(prcomp_res_5, data = annot, colour = "Tx_Time", size =4)+
  theme_bw()+
  scale_color_manual(values = c(fill_col_txtime))+
  ggrepel::geom_text_repel(label= ind_num)+
  ggtitle("RUVs Correction k=5")

# annot_prcomp_res_5 %>% ggplot(., aes(x=PC1, y=PC2, size = 10)) +
#   geom_point(aes(color = Ind, shape = Time, fill = Tx)) +
#                        scale_shape_manual(values = c(21, 22, 24)) +
#   scale_fill_manual(values =  fill_col_tx)+
#   scale_color_manual(values = c(fill_col_ind_dark))+
#   guides(fill=guide_legend(override.aes=list(shape=21)))+
#   guides(color=guide_legend(override.aes=list(shape=21)))+
#   guides(fill=guide_legend(override.aes=list(shape=21,fill=fill_col_tx,color=fill_col_tx)))+
#   ggtitle("RUVs k=5")

#k=5
annot$samples == RUV_df_rm5$Names
annot$RUV_5 <- RUV_df_rm5$W_5

#k=5
mm_r5 <- model.matrix(~0 + group_2 + RUV_5, data = annot)

p5 <- voom(dge1_calc$counts, mm_r5, plot = TRUE)

corfit5 <- duplicateCorrelation(p5, mm_r5, block = snames1_ind)

v5 <- voom(dge1_calc$counts, mm_r5, block = snames1_ind, correlation = corfit5$consensus)

fit5 <- lmFit(v5, mm_r5, block = snames1_ind, correlation = corfit5$consensus)


#k=5
mm_r5_names <- str_replace(string = colnames(mm_r5), pattern = "group_2", replacement = "")
design <- model.matrix(~ group_2 + RUV_5 , annot)
colnames(mm_r5) <- mm_r5_names

#k=5
cm_r5 <- makeContrasts(
        V.D24 = DOX_24 - DMSO_24,
        V.F24 = FLUO_24 - DMSO_24,
        V.D24r = DOX_24rec - DMSO_24rec,
        V.F24r = FLUO_24rec - DMSO_24rec,
        V.D144r = DOX_144rec - DMSO_144rec,
        V.F144r = FLUO_144rec - DMSO_144rec,
        RUV_5_24 = RUV_5 - DMSO_24,
        RUV_5_24r = RUV_5 - DMSO_24rec,
        RUV_5_144r = RUV_5 - DMSO_144rec,
        levels = mm_r5
)


#k=5
vfit_r5 <- lmFit(p5, mm_r5)
vfit_r5 <- contrasts.fit(vfit_r5, contrasts = cm_r5)

#k=5
efit5 <- eBayes(vfit_r5)

#k=5
results5 = decideTests(efit5)
summary(results5)

#k=5
toptable5_Dupcor_DOX <- topTable(efit5, coef = "V.D24", number = nrow(dge1_calc$counts), p.value = 1)
toptable5_Dupcor_DOXrec <- topTable(efit5, coef = "V.D24r", number = nrow(dge1_calc$counts), p.value = 1)
toptable5_Dupcor_DOX144 <- topTable(efit5, coef = "V.D144r", number = nrow(dge1_calc$counts), p.value = 1)
#k=5 plots
toptable5_Dupcor_DOX$logFC %>% hist(, main= "RUVs k=5 DOX 24hr Toptable")
toptable5_Dupcor_DOXrec$logFC %>% hist(, main = "RUVs k=5 DOX 24Rec Toptable")
toptable5_Dupcor_DOX144$logFC %>% hist(, main = "RUVs k=5 DOX 144Rec Toptable")

```


```{r RUVs k6 Data}
#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set6 <- RUVSeq::RUVs(x = counts, k =6, scIdx = scIdx, isLog = TRUE)

#get the ruv weights to put into the linear model. n weights = k.
#k=6
RUV_df6 <- set6$W %>% as.data.frame()
RUV_df6$Names <- rownames(RUV_df6)

#check that the names match
#k=6
RUV_df_rm6 <- RUV_df6[RUV_df6$Names %in% annot$samples, ] 
RUV_6 <-  RUV_df_rm6$W_6

#ruv k=6 PCA
prcomp_res_6 <- prcomp(t(set6$normalizedCounts), scale. = FALSE, center = TRUE)
ggplot2::autoplot(prcomp_res_6, data = annot, colour = "Tx_Time", size =4)+
  theme_bw()+
  scale_color_manual(values = c(fill_col_txtime))+
  ggrepel::geom_text_repel(label= ind_num)+
  ggtitle("RUVs Correction k=6")

#k=6
# prcomp_res_6 <- prcomp(t(set6$normalizedCounts), scale. = FALSE, center = TRUE)
# annot_prcomp_res_6 <- prcomp_res_6$x %>% cbind(., annot)
# 
# annot_prcomp_res_6 %>% ggplot(., aes(x=PC1, y=PC2, size = 10)) +
#   geom_point(aes(color = Ind, shape = Time, fill = Tx)) +
#                        scale_shape_manual(values = c(21, 22, 24)) +
#   scale_fill_manual(values =  fill_col_tx)+
#   scale_color_manual(values = c(fill_col_ind_dark))+
#   guides(fill=guide_legend(override.aes=list(shape=21)))+
#   guides(color=guide_legend(override.aes=list(shape=21)))+
#   guides(fill=guide_legend(override.aes=list(shape=21,fill=fill_col_tx,color=fill_col_tx)))+
#   ggtitle("RUVs k=6")

#k=6
annot$samples == RUV_df_rm6$Names
annot$RUV_6 <- RUV_df_rm6$W_6

#k=6
mm_r6 <- model.matrix(~0 + group_2 + RUV_6, data = annot)

p6 <- voom(dge1_calc$counts, mm_r6, plot = TRUE)

corfit6 <- duplicateCorrelation(p6, mm_r6, block = snames1_ind)

v6 <- voom(dge1_calc$counts, mm_r6, block = snames1_ind, correlation = corfit6$consensus)

fit6 <- lmFit(v6, mm_r6, block = snames1_ind, correlation = corfit6$consensus)


#k=6
mm_r6_names <- str_replace(string = colnames(mm_r6), pattern = "group_2", replacement = "")
design <- model.matrix(~ group_2 + RUV_6 , annot)
colnames(mm_r6) <- mm_r6_names

#k=6
cm_r6 <- makeContrasts(
        V.D24 = DOX_24 - DMSO_24,
        V.F24 = FLUO_24 - DMSO_24,
        V.D24r = DOX_24rec - DMSO_24rec,
        V.F24r = FLUO_24rec - DMSO_24rec,
        V.D144r = DOX_144rec - DMSO_144rec,
        V.F144r = FLUO_144rec - DMSO_144rec,
        RUV_6_24 = RUV_6 - DMSO_24,
        RUV_6_24r = RUV_6 - DMSO_24rec,
        RUV_6_144r = RUV_6 - DMSO_144rec,
        levels = mm_r6
)


#k=6
vfit_r6 <- lmFit(p6, mm_r6)
vfit_r6 <- contrasts.fit(vfit_r6, contrasts = cm_r6)

#k=6
efit6 <- eBayes(vfit_r6)

#k=6
results6 = decideTests(efit6)
summary(results6)

#k=6
toptable6_Dupcor_DOX <- topTable(efit6, coef = "V.D24", number = nrow(dge1_calc$counts), p.value = 1)
toptable6_Dupcor_DOXrec <- topTable(efit6, coef = "V.D24r", number = nrow(dge1_calc$counts), p.value = 1)
toptable6_Dupcor_DOX144 <- topTable(efit6, coef = "V.D144r", number = nrow(dge1_calc$counts), p.value = 1)
#k=6 plots
toptable6_Dupcor_DOX$logFC %>% hist(, main= "RUVs k=6 DOX 24hr Toptable")
toptable6_Dupcor_DOXrec$logFC %>% hist(, main = "RUVs k=6 DOX 24Rec Toptable")
toptable6_Dupcor_DOX144$logFC %>% hist(, main = "RUVs k=6 DOX 144Rec Toptable")

```

```{r RUVs k7 Data}
#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set7 <- RUVSeq::RUVs(x = counts, k =7, scIdx = scIdx, isLog = TRUE)

#get the ruv weights to put into the linear model. n weights = k.
#k=7
RUV_df7 <- set7$W %>% as.data.frame()
RUV_df7$Names <- rownames(RUV_df7)

#check that the names match
#k=7
RUV_df_rm7 <- RUV_df7[RUV_df7$Names %in% annot$samples, ] 
RUV_7 <-  RUV_df_rm7$W_7

#ruv k=7 PCA
prcomp_res_7 <- prcomp(t(set7$normalizedCounts), scale. = FALSE, center = TRUE)

ggplot2::autoplot(prcomp_res_7, data = annot, colour = "Tx_Time", size =4)+
  theme_bw()+
  scale_color_manual(values = c(fill_col_txtime))+
  ggrepel::geom_text_repel(label= ind_num)+
  ggtitle("RUVs Correction k=7")

#k=7

# annot_prcomp_res_7 %>% ggplot(., aes(x=PC1, y=PC2, size = 10)) +
#   geom_point(aes(color = Ind, shape = Time, fill = Tx)) +
#                        scale_shape_manual(values = c(21, 22, 24)) +
#   scale_fill_manual(values =  fill_col_tx)+
#   scale_color_manual(values = c(fill_col_ind_dark))+
#   guides(fill=guide_legend(override.aes=list(shape=21)))+
#   guides(color=guide_legend(override.aes=list(shape=21)))+
#   guides(fill=guide_legend(override.aes=list(shape=21,fill=fill_col_tx,color=fill_col_tx)))+
#   ggtitle("RUVs k=7")

#k=7
annot$samples == RUV_df_rm7$Names
annot$RUV_7 <- RUV_df_rm7$W_7

#k=7
mm_r7 <- model.matrix(~0 + group_2 + RUV_7, data = annot)

p7 <- voom(dge1_calc$counts, mm_r7, plot = TRUE)

corfit7 <- duplicateCorrelation(p7, mm_r7, block = snames1_ind)

v7 <- voom(dge1_calc$counts, mm_r7, block = snames1_ind, correlation = corfit7$consensus)

fit7 <- lmFit(v7, mm_r7, block = snames1_ind, correlation = corfit7$consensus)


#k=7
mm_r7_names <- str_replace(string = colnames(mm_r7), pattern = "group_2", replacement = "")
design <- model.matrix(~ group_2 + RUV_7 , annot)
colnames(mm_r7) <- mm_r7_names

#k=7
cm_r7 <- makeContrasts(
        V.D24 = DOX_24 - DMSO_24,
        V.F24 = FLUO_24 - DMSO_24,
        V.D24r = DOX_24rec - DMSO_24rec,
        V.F24r = FLUO_24rec - DMSO_24rec,
        V.D144r = DOX_144rec - DMSO_144rec,
        V.F144r = FLUO_144rec - DMSO_144rec,
        RUV_7_24 = RUV_7 - DMSO_24,
        RUV_7_24r = RUV_7 - DMSO_24rec,
        RUV_7_144r = RUV_7 - DMSO_144rec,
        levels = mm_r7
)


#k=7
vfit_r7 <- lmFit(p7, mm_r7)
vfit_r7 <- contrasts.fit(vfit_r7, contrasts = cm_r7)

#k=7
efit7 <- eBayes(vfit_r7)

#k=7
results7 = decideTests(efit7)
summary(results7)

#k=7
toptable7_Dupcor_DOX <- topTable(efit7, coef = "V.D24", number = nrow(dge1_calc$counts), p.value = 1)
toptable7_Dupcor_DOXrec <- topTable(efit7, coef = "V.D24r", number = nrow(dge1_calc$counts), p.value = 1)
toptable7_Dupcor_DOX144 <- topTable(efit7, coef = "V.D144r", number = nrow(dge1_calc$counts), p.value = 1)
#k=7 plots
toptable7_Dupcor_DOX$logFC %>% hist(, main= "RUVs k=7 DOX 24hr Toptable")
toptable7_Dupcor_DOXrec$logFC %>% hist(, main = "RUVs k=7 DOX 24Rec Toptable")
toptable7_Dupcor_DOX144$logFC %>% hist(, main = "RUVs k=7 DOX 144Rec Toptable")

```

```{r RUVs k8 Data}
#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set8 <- RUVSeq::RUVs(x = counts, k =8, scIdx = scIdx, isLog = TRUE)

#get the ruv weights to put into the linear model. n weights = k.
#k=8
RUV_df8 <- set8$W %>% as.data.frame()
RUV_df8$Names <- rownames(RUV_df8)

#check that the names match
#k=8
RUV_df_rm8 <- RUV_df8[RUV_df8$Names %in% annot$samples, ] 
RUV_8 <-  RUV_df_rm8$W_8

#ruv k=8 PCA
prcomp_res_8 <- prcomp(t(set8$normalizedCounts), scale. = FALSE, center = TRUE)
ggplot2::autoplot(prcomp_res_8, data = annot, colour = "Tx_Time", size =4)+
  theme_bw()+
  scale_color_manual(values = c(fill_col_txtime))+
  ggrepel::geom_text_repel(label= ind_num)+
  ggtitle("RUVs Correction k=8")

#k=8
prcomp_res_8 <- prcomp(t(set8$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_8 <- prcomp_res_8$x %>% cbind(., annot)

# annot_prcomp_res_8 %>% ggplot(., aes(x=PC1, y=PC2, size = 10)) +
#   geom_point(aes(color = Ind, shape = Time, fill = Tx)) +
#                        scale_shape_manual(values = c(21, 22, 24)) +
#   scale_fill_manual(values =  fill_col_tx)+
#   scale_color_manual(values = c(fill_col_ind_dark))+
#   guides(fill=guide_legend(override.aes=list(shape=21)))+
#   guides(color=guide_legend(override.aes=list(shape=21)))+
#   guides(fill=guide_legend(override.aes=list(shape=21,fill=fill_col_tx,color=fill_col_tx)))+
#   ggtitle("RUVs k=8")

#k=8
annot$samples == RUV_df_rm8$Names
annot$RUV_8 <- RUV_df_rm8$W_8

#k=8
mm_r8 <- model.matrix(~0 + group_2 + RUV_8, data = annot)

p8 <- voom(dge1_calc$counts, mm_r8, plot = TRUE)

corfit8 <- duplicateCorrelation(p8, mm_r8, block = snames1_ind)

v8 <- voom(dge1_calc$counts, mm_r8, block = snames1_ind, correlation = corfit8$consensus)

fit8 <- lmFit(v8, mm_r8, block = snames1_ind, correlation = corfit8$consensus)


#k=8
mm_r8_names <- str_replace(string = colnames(mm_r8), pattern = "group_2", replacement = "")
design <- model.matrix(~ group_2 + RUV_8 , annot)
colnames(mm_r8) <- mm_r8_names

#k=8
cm_r8 <- makeContrasts(
        V.D24 = DOX_24 - DMSO_24,
        V.F24 = FLUO_24 - DMSO_24,
        V.D24r = DOX_24rec - DMSO_24rec,
        V.F24r = FLUO_24rec - DMSO_24rec,
        V.D144r = DOX_144rec - DMSO_144rec,
        V.F144r = FLUO_144rec - DMSO_144rec,
        RUV_8_24 = RUV_8 - DMSO_24,
        RUV_8_24r = RUV_8 - DMSO_24rec,
        RUV_8_144r = RUV_8 - DMSO_144rec,
        levels = mm_r8
)


#k=8
vfit_r8 <- lmFit(p8, mm_r8)
vfit_r8 <- contrasts.fit(vfit_r8, contrasts = cm_r8)

#k=8
efit8 <- eBayes(vfit_r8)

#k=8
results8 = decideTests(efit8)
summary(results8)

#k=8
toptable8_Dupcor_DOX <- topTable(efit8, coef = "V.D24", number = nrow(dge1_calc$counts), p.value = 1)
toptable8_Dupcor_DOXrec <- topTable(efit8, coef = "V.D24r", number = nrow(dge1_calc$counts), p.value = 1)
toptable8_Dupcor_DOX144 <- topTable(efit8, coef = "V.D144r", number = nrow(dge1_calc$counts), p.value = 1)
#k=8 plots
toptable8_Dupcor_DOX$logFC %>% hist(, main= "RUVs k=8 DOX 24hr Toptable")
toptable8_Dupcor_DOXrec$logFC %>% hist(, main = "RUVs k=8 DOX 24Rec Toptable")
toptable8_Dupcor_DOX144$logFC %>% hist(, main = "RUVs k=8 DOX 144Rec Toptable")

```

```{r RUVs k9 Data}
#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set9 <- RUVSeq::RUVs(x = counts, k =9, scIdx = scIdx, isLog = TRUE)

#get the ruv weights to put into the linear model. n weights = k.
#k=9
RUV_df9 <- set9$W %>% as.data.frame()
RUV_df9$Names <- rownames(RUV_df9)

#check that the names match
#k=9
RUV_df_rm9 <- RUV_df9[RUV_df9$Names %in% annot$samples, ] 
RUV_9 <-  RUV_df_rm9$W_9

#ruv k=9 PCA
prcomp_res_9 <- prcomp(t(set9$normalizedCounts), scale. = FALSE, center = TRUE)
ggplot2::autoplot(prcomp_res_9, data = annot, colour = "Tx_Time", size =4)+
  theme_bw()+
  scale_color_manual(values = c(fill_col_txtime))+
  ggrepel::geom_text_repel(label= ind_num)+
  ggtitle("RUVs Correction k=9")

#k=9
prcomp_res_9 <- prcomp(t(set9$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_9 <- prcomp_res_9$x %>% cbind(., annot)

# annot_prcomp_res_9 %>% ggplot(., aes(x=PC1, y=PC2, size = 10)) +
#   geom_point(aes(color = Ind, shape = Time, fill = Tx)) +
#                        scale_shape_manual(values = c(21, 22, 24)) +
#   scale_fill_manual(values =  fill_col_tx)+
#   scale_color_manual(values = c(fill_col_ind_dark))+
#   guides(fill=guide_legend(override.aes=list(shape=21)))+
#   guides(color=guide_legend(override.aes=list(shape=21)))+
#   guides(fill=guide_legend(override.aes=list(shape=21,fill=fill_col_tx,color=fill_col_tx)))+
#   ggtitle("RUVs k=9")

#k=9
annot$samples == RUV_df_rm9$Names
annot$RUV_9 <- RUV_df_rm9$W_9

#k=9
mm_r9 <- model.matrix(~0 + group_2 + RUV_9, data = annot)

p9 <- voom(dge1_calc$counts, mm_r9, plot = TRUE)

corfit9 <- duplicateCorrelation(p9, mm_r9, block = snames1_ind)

v9 <- voom(dge1_calc$counts, mm_r9, block = snames1_ind, correlation = corfit9$consensus)

fit9 <- lmFit(v9, mm_r9, block = snames1_ind, correlation = corfit9$consensus)


#k=9
mm_r9_names <- str_replace(string = colnames(mm_r9), pattern = "group_2", replacement = "")
design <- model.matrix(~ group_2 + RUV_9 , annot)
colnames(mm_r9) <- mm_r9_names

#k=9
cm_r9 <- makeContrasts(
        V.D24 = DOX_24 - DMSO_24,
        V.F24 = FLUO_24 - DMSO_24,
        V.D24r = DOX_24rec - DMSO_24rec,
        V.F24r = FLUO_24rec - DMSO_24rec,
        V.D144r = DOX_144rec - DMSO_144rec,
        V.F144r = FLUO_144rec - DMSO_144rec,
        RUV_9_24 = RUV_9 - DMSO_24,
        RUV_9_24r = RUV_9 - DMSO_24rec,
        RUV_9_144r = RUV_9 - DMSO_144rec,
        levels = mm_r9
)


#k=9
vfit_r9 <- lmFit(p9, mm_r9)
vfit_r9 <- contrasts.fit(vfit_r9, contrasts = cm_r9)

#k=9
efit9 <- eBayes(vfit_r9)

#k=9
results9 = decideTests(efit9)
summary(results9)

#k=9
toptable9_Dupcor_DOX <- topTable(efit9, coef = "V.D24", number = nrow(dge1_calc$counts), p.value = 1)
toptable9_Dupcor_DOXrec <- topTable(efit9, coef = "V.D24r", number = nrow(dge1_calc$counts), p.value = 1)
toptable9_Dupcor_DOX144 <- topTable(efit9, coef = "V.D144r", number = nrow(dge1_calc$counts), p.value = 1)
#k=9 plots
toptable9_Dupcor_DOX$logFC %>% hist(, main= "RUVs k=9 DOX 24hr Toptable")
toptable9_Dupcor_DOXrec$logFC %>% hist(, main = "RUVs k=9 DOX 24Rec Toptable")
toptable9_Dupcor_DOX144$logFC %>% hist(, main = "RUVs k=9 DOX 144Rec Toptable")

```

```{r RUVs k10 Data}
#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set10 <- RUVSeq::RUVs(x = counts, k =10, scIdx = scIdx, isLog = TRUE)

#get the ruv weights to put into the linear model. n weights = k.
#k=10
RUV_df10 <- set10$W %>% as.data.frame()
RUV_df10$Names <- rownames(RUV_df10)

#check that the names match
#k=10
RUV_df_rm10 <- RUV_df10[RUV_df10$Names %in% annot$samples, ] 
RUV_10 <-  RUV_df_rm10$W_10

#ruv k=10 PCA
prcomp_res_10 <- prcomp(t(set10$normalizedCounts), scale. = FALSE, center = TRUE)
ggplot2::autoplot(prcomp_res_10, data = annot, colour = "Tx_Time", size =4)+
  theme_bw()+
  scale_color_manual(values = c(fill_col_txtime))+
  ggrepel::geom_text_repel(label= ind_num)+
  ggtitle("RUVs Correction k=10")

#k=10
prcomp_res_10 <- prcomp(t(set10$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_10 <- prcomp_res_10$x %>% cbind(., annot)

# annot_prcomp_res_10 %>% ggplot(., aes(x=PC1, y=PC2, size = 10)) +
#   geom_point(aes(color = Ind, shape = Time, fill = Tx)) +
#                        scale_shape_manual(values = c(21, 22, 24)) +
#   scale_fill_manual(values =  fill_col_tx)+
#   scale_color_manual(values = c(fill_col_ind_dark))+
#   guides(fill=guide_legend(override.aes=list(shape=21)))+
#   guides(color=guide_legend(override.aes=list(shape=21)))+
#   guides(fill=guide_legend(override.aes=list(shape=21,fill=fill_col_tx,color=fill_col_tx)))+
#   ggtitle("RUVs k=10")

#k=10
annot$samples == RUV_df_rm10$Names
annot$RUV_10 <- RUV_df_rm10$W_10

#k=10
mm_r10 <- model.matrix(~0 + group_2 + RUV_10, data = annot)

p10 <- voom(dge1_calc$counts, mm_r10, plot = TRUE)

corfit10 <- duplicateCorrelation(p10, mm_r10, block = snames1_ind)

v10 <- voom(dge1_calc$counts, mm_r10, block = snames1_ind, correlation = corfit10$consensus)

fit10 <- lmFit(v10, mm_r10, block = snames1_ind, correlation = corfit10$consensus)


#k=10
mm_r10_names <- str_replace(string = colnames(mm_r10), pattern = "group_2", replacement = "")
design <- model.matrix(~ group_2 + RUV_10 , annot)
colnames(mm_r10) <- mm_r10_names

#k=10
cm_r10 <- makeContrasts(
        V.D24 = DOX_24 - DMSO_24,
        V.F24 = FLUO_24 - DMSO_24,
        V.D24r = DOX_24rec - DMSO_24rec,
        V.F24r = FLUO_24rec - DMSO_24rec,
        V.D144r = DOX_144rec - DMSO_144rec,
        V.F144r = FLUO_144rec - DMSO_144rec,
        RUV_10_24 = RUV_10 - DMSO_24,
        RUV_10_24r = RUV_10 - DMSO_24rec,
        RUV_10_144r = RUV_10 - DMSO_144rec,
        levels = mm_r10
)


#k=10
vfit_r10 <- lmFit(p10, mm_r10)
vfit_r10 <- contrasts.fit(vfit_r10, contrasts = cm_r10)

#k=10
efit10 <- eBayes(vfit_r10)

#k=10
results10 = decideTests(efit10)
summary(results10)

#k=10
toptable10_Dupcor_DOX <- topTable(efit10, coef = "V.D24", number = nrow(dge1_calc$counts), p.value = 1)
toptable10_Dupcor_DOXrec <- topTable(efit10, coef = "V.D24r", number = nrow(dge1_calc$counts), p.value = 1)
toptable10_Dupcor_DOX144 <- topTable(efit10, coef = "V.D144r", number = nrow(dge1_calc$counts), p.value = 1)
#k=10 plots
toptable10_Dupcor_DOX$logFC %>% hist(, main= "RUVs k=10 DOX 24hr Toptable")
toptable10_Dupcor_DOXrec$logFC %>% hist(, main = "RUVs k=10 DOX 24Rec Toptable")
toptable10_Dupcor_DOX144$logFC %>% hist(, main = "RUVs k=10 DOX 144Rec Toptable")

```

```{r pvalue and adj pvalue plots of DE, include=FALSE}

####DOX 24####
#no RUVs
top.table_V.D24 %>% ggplot(aes(x=P.Value))+
  geom_density()+
  ggtitle("DOX24 noRUV P value dist")
#k=1
toptable_Dupcor_DOX %>% ggplot(aes(x=P.Value))+
  geom_density()+
  ggtitle("DOX24 RUVs k=1 P value dist")
#k=2
toptable2_Dupcor_DOX %>% ggplot(aes(x=P.Value))+
  geom_density()+
  ggtitle("DOX24 RUVs k=2 P value dist")
#no RUV
top.table_V.D24 %>% ggplot(aes(x=P.Value))+
  geom_density()+
  ggtitle("DOX24 noRUV adj. P value dist")
#k=1
toptable_Dupcor_DOX %>% ggplot(aes(x=adj.P.Val))+
  geom_density()+
  ggtitle("DOX24 RUVs k=1 adj. P value dist")
#k=2
toptable2_Dupcor_DOX %>% ggplot(aes(x=adj.P.Val))+
  geom_density()+
  ggtitle("DOX24 RUVs k=2 adj. P value dist")

####DOX 24rec####
#no RUV
top.table_V.D24r %>% ggplot(aes(x=P.Value))+
  geom_density()+
  ggtitle("DOX24rec noRUV P value dist")
#k=1
toptable_Dupcor_DOXrec %>% ggplot(aes(x=P.Value))+
  geom_density()+  
  ggtitle("DOX24rec RUVs k=1 P value dist")
#k=2
toptable2_Dupcor_DOXrec %>% ggplot(aes(x=P.Value))+
  geom_density()+
  ggtitle("DOX24rec RUVs k=2 P value dist")
#no RUV
top.table_V.D24r %>% ggplot(aes(x=adj.P.Val))+
  geom_density()+
  ggtitle("DOX24rec noRUV adj. P value dist")
#k=1
toptable_Dupcor_DOXrec %>% ggplot(aes(x=adj.P.Val))+
  geom_density()+
    ggtitle("DOX24rec RUVs k=1 adj. P value dist")
#k=2
toptable2_Dupcor_DOXrec %>% ggplot(aes(x=adj.P.Val))+
  geom_density()+
  ggtitle("DOX24rec RUVs k=2 adj. P value dist")

####DOX 144rec####
#no RUV
top.table_V.D144r %>% ggplot(aes(x=P.Value))+
  geom_density()+
  ggtitle("DOX144rec noRUV P value dist")
#k=1
toptable_Dupcor_DOX144 %>% ggplot(aes(x=P.Value))+
  geom_density()+
  ggtitle("DOX144rec RUVs k=1 P value dist")
#k=2
toptable2_Dupcor_DOX144 %>% ggplot(aes(x=P.Value))+
  geom_density()+
  ggtitle("DOX144rec RUVs k=2 P value dist")
#no RUV
top.table_V.D144r %>% ggplot(aes(x=adj.P.Val))+
  geom_density()+
  ggtitle("DOX144rec noRUV adj. P value dist")
#k=1
toptable_Dupcor_DOX144 %>% ggplot(aes(x=adj.P.Val))+
  geom_density()+
  ggtitle("DOX144rec RUVs k=1 adj. P value dist")
#k=2
toptable2_Dupcor_DOX144 %>% ggplot(aes(x=adj.P.Val))+
  geom_density()+
  ggtitle("DOX144rec RUVs k=2 adj. P value dist")

```


Now I want to attempt to use Cormotif to look at motifs within my conditions
```{r Cormotif Function, eval=TRUE, warning=FALSE, include=FALSE}
limmafit.default <- function(exprs, groupid, compid) {
  limmafits <- list()
  compnum <- nrow(compid)
  genenum <- nrow(exprs)
  limmat <- matrix(0, genenum,compnum)
  limmas2 <- rep(0, compnum)
  limmadf <- rep(0, compnum)
  limmav0    <- rep(0,compnum)
  limmag1num <- rep(0,compnum)
  limmag2num <- rep(0,compnum)

  rownames(limmat)  <- rownames(exprs)
  colnames(limmat)  <- rownames(compid)
  names(limmas2)    <- rownames(compid)
  names(limmadf)    <- rownames(compid)
  names(limmav0)    <- rownames(compid)
  names(limmag1num) <- rownames(compid)
  names(limmag2num) <- rownames(compid)
  
  for(i in 1:compnum) {
    selid1 <- which(groupid == compid[i,1])
    selid2 <- which(groupid == compid[i,2])
    eset   <- new("ExpressionSet", exprs=cbind(exprs[,selid1],exprs[,selid2]))
    g1num  <- length(selid1)
    g2num  <- length(selid2)
    designmat <- cbind(base=rep(1,(g1num+g2num)), delta=c(rep(0,g1num),rep(1,g2num)))
    fit <- lmFit(eset,designmat)
    fit <- eBayes(fit)
    limmat[,i] <- fit$t[,2]
    limmas2[i] <- fit$s2.prior
    limmadf[i] <- fit$df.prior
    limmav0[i] <- fit$var.prior[2]
    limmag1num[i] <- g1num
    limmag2num[i] <- g2num
    limmafits[[i]] <- fit
  }
  names(limmafits) <- rownames(compid)
  limmacompnum<-nrow(compid)
  result<-list(t       = limmat,
               v0      = limmav0,
               df0     = limmadf,
               s20     = limmas2,
               g1num   = limmag1num,
               g2num   = limmag2num,
               compnum = limmacompnum,
               fits    = limmafits)
}

limmafit.counts <-
  function (exprs, groupid, compid, norm.factor.method = "TMM", voom.normalize.method = "none")
  {
    limmafits  <- list()
    compnum    <- nrow(compid)
    genenum    <- nrow(exprs)
    limmat     <- matrix(NA,genenum,compnum)
    limmas2    <- rep(0,compnum)
    limmadf    <- rep(0,compnum)
    limmav0    <- rep(0,compnum)
    limmag1num <- rep(0,compnum)
    limmag2num <- rep(0,compnum)

    rownames(limmat)  <- rownames(exprs)
    colnames(limmat)  <- rownames(compid)
    names(limmas2)    <- rownames(compid)
    names(limmadf)    <- rownames(compid)
    names(limmav0)    <- rownames(compid)
    names(limmag1num) <- rownames(compid)
    names(limmag2num) <- rownames(compid)

    for (i in 1:compnum) {
      message(paste("Running limma for comparision",i,"/",compnum))
      selid1 <- which(groupid == compid[i, 1])
      selid2 <- which(groupid == compid[i, 2])
      # make a new count data frame
      counts <- cbind(exprs[, selid1], exprs[, selid2])

      # remove NAs
      not.nas <- which(apply(counts, 1, function(x) !any(is.na(x))) == TRUE)

      # runn voom/limma
      d <- DGEList(counts[not.nas,])
      d <- calcNormFactors(d, method = norm.factor.method)
      g1num <- length(selid1)
      g2num <- length(selid2)
      designmat <- cbind(base = rep(1, (g1num + g2num)), delta = c(rep(0,
                                                                       g1num), rep(1, g2num)))

      y <- voom(d, designmat, normalize.method = voom.normalize.method)
      fit <- lmFit(y, designmat)
      fit <- eBayes(fit)

      limmafits[[i]] <- fit
      limmat[not.nas, i] <- fit$t[, 2]
      limmas2[i] <- fit$s2.prior
      limmadf[i] <- fit$df.prior
      limmav0[i] <- fit$var.prior[2]
      limmag1num[i] <- g1num
      limmag2num[i] <- g2num
    }
    limmacompnum <- nrow(compid)
    names(limmafits) <- rownames(compid)
    result <- list(t       = limmat,
                   v0      = limmav0,
                   df0     = limmadf,
                   s20     = limmas2,
                   g1num   = limmag1num,
                   g2num   = limmag2num,
                   compnum = limmacompnum,
                   fits    = limmafits)
  }


limmafit.list <-
  function (fitlist, cmp.idx=2)
  {
    compnum    <- length(fitlist)

    genes <- c()
    for (i in 1:compnum) genes <- unique(c(genes, rownames(fitlist[[i]])))

    genenum    <- length(genes)
    limmat     <- matrix(NA,genenum,compnum)
    limmas2    <- rep(0,compnum)
    limmadf    <- rep(0,compnum)
    limmav0    <- rep(0,compnum)
    limmag1num <- rep(0,compnum)
    limmag2num <- rep(0,compnum)

    rownames(limmat)  <- genes
    colnames(limmat)  <- names(fitlist)
    names(limmas2)    <- names(fitlist)
    names(limmadf)    <- names(fitlist)
    names(limmav0)    <- names(fitlist)
    names(limmag1num) <- names(fitlist)
    names(limmag2num) <- names(fitlist)

    for (i in 1:compnum) {
      this.t <- fitlist[[i]]$t[,cmp.idx]
      limmat[names(this.t),i] <- this.t

      limmas2[i]    <- fitlist[[i]]$s2.prior
      limmadf[i]    <- fitlist[[i]]$df.prior
      limmav0[i]    <- fitlist[[i]]$var.prior[cmp.idx]
      limmag1num[i] <- sum(fitlist[[i]]$design[,cmp.idx]==0)
      limmag2num[i] <- sum(fitlist[[i]]$design[,cmp.idx]==1)
    }

    limmacompnum <- compnum
    result <- list(t       = limmat,
                   v0      = limmav0,
                   df0     = limmadf,
                   s20     = limmas2,
                   g1num   = limmag1num,
                   g2num   = limmag2num,
                   compnum = limmacompnum,
                   fits    = limmafits)

  }


generank<-function(x) {
  xcol<-ncol(x)
  xrow<-nrow(x)
  result<-matrix(0,xrow,xcol)
  z<-(1:1:xrow)
  for(i in 1:xcol) {
    y<-sort(x[,i],decreasing=TRUE,na.last=TRUE)
    result[,i]<-match(x[,i],y)
    result[,i]<-order(result[,i])
  }
  result
}

## Log-likelihood for moderated t under H0
modt.f0.loglike<-function(x,df) {
  a<-dt(x, df, log=TRUE)
  result<-as.vector(a)
  flag<-which(is.na(result)==TRUE)
  result[flag]<-0
  result
}

## Log-likelihood for moderated t under H1
## param=c(df,g1num,g2num,v0)
modt.f1.loglike<-function(x,param) {
  df<-param[1]
  g1num<-param[2]
  g2num<-param[3]
  v0<-param[4]
  w<-sqrt(1+v0/(1/g1num+1/g2num))
  dt(x/w, df, log=TRUE)-log(w)
  a<-dt(x/w, df, log=TRUE)-log(w)
  result<-as.vector(a)
  flag<-which(is.na(result)==TRUE)
  result[flag]<-0
  result
}

## Correlation Motif Fit
cmfit.X<-function(x, type, K=1, tol=1e-3, max.iter=100) {
  ## initialize
  xrow <- nrow(x)
  xcol <- ncol(x)
  loglike0 <- list()
  loglike1 <- list()
  p <- rep(1, K)/K
  q <- matrix(runif(K * xcol), K, xcol)
  q[1, ] <- rep(0.01, xcol)
  for (i in 1:xcol) {
    f0 <- type[[i]][[1]]
    f0param <- type[[i]][[2]]
    f1 <- type[[i]][[3]]
    f1param <- type[[i]][[4]]
    loglike0[[i]] <- f0(x[, i], f0param)
    loglike1[[i]] <- f1(x[, i], f1param)
  }
  condlike <- list()
  for (i in 1:xcol) {
    condlike[[i]] <- matrix(0, xrow, K)
  }
  loglike.old <- -1e+10
  for (i.iter in 1:max.iter) {
    if ((i.iter%%50) == 0) {
      print(paste("We have run the first ", i.iter, " iterations for K=",
                  K, sep = ""))
    }
    err <- tol + 1
    clustlike <- matrix(0, xrow, K)
    #templike <- matrix(0, xrow, 2)
    templike1 <- rep(0, xrow)
    templike2 <- rep(0, xrow)
    for (j in 1:K) {
      for (i in 1:xcol) {
        templike1 <- log(q[j, i]) + loglike1[[i]]
        templike2 <- log(1 - q[j, i]) + loglike0[[i]]
        tempmax <- Rfast::Pmax(templike1, templike2)

        templike1 <- exp(templike1 - tempmax)
        templike2 <- exp(templike2 - tempmax)

        tempsum <- templike1 + templike2
        clustlike[, j] <- clustlike[, j] + tempmax +
          log(tempsum)
        condlike[[i]][, j] <- templike1/tempsum
      }
      clustlike[, j] <- clustlike[, j] + log(p[j])
    }
    #tempmax <- apply(clustlike, 1, max)
    tempmax <- Rfast::rowMaxs(clustlike, value=TRUE)
    for (j in 1:K) {
      clustlike[, j] <- exp(clustlike[, j] - tempmax)
    }
    #tempsum <- apply(clustlike, 1, sum)
    tempsum <- Rfast::rowsums(clustlike)
    for (j in 1:K) {
      clustlike[, j] <- clustlike[, j]/tempsum
    }
    #p.new <- (apply(clustlike, 2, sum) + 1)/(xrow + K)
    p.new <- (Rfast::colsums(clustlike) + 1)/(xrow + K)
    q.new <- matrix(0, K, xcol)
    for (j in 1:K) {
      clustpsum <- sum(clustlike[, j])
      for (i in 1:xcol) {
        q.new[j, i] <- (sum(clustlike[, j] * condlike[[i]][,
                                                           j]) + 1)/(clustpsum + 2)
      }
    }
    err.p <- max(abs(p.new - p)/p)
    err.q <- max(abs(q.new - q)/q)
    err <- max(err.p, err.q)
    loglike.new <- (sum(tempmax + log(tempsum)) + sum(log(p.new)) +
                      sum(log(q.new) + log(1 - q.new)))/xrow
    p <- p.new
    q <- q.new
    loglike.old <- loglike.new
    if (err < tol) {
      break
    }
  }
  clustlike <- matrix(0, xrow, K)
  for (j in 1:K) {
    for (i in 1:xcol) {
      templike1 <- log(q[j, i]) + loglike1[[i]]
      templike2 <- log(1 - q[j, i]) + loglike0[[i]]
      tempmax <- Rfast::Pmax(templike1, templike2)

      templike1 <- exp(templike1 - tempmax)
      templike2 <- exp(templike2 - tempmax)

      tempsum <- templike1 + templike2
      clustlike[, j] <- clustlike[, j] + tempmax + log(tempsum)
      condlike[[i]][, j] <- templike1/tempsum
    }
    clustlike[, j] <- clustlike[, j] + log(p[j])
  }
  #tempmax <- apply(clustlike, 1, max)
  tempmax <- Rfast::rowMaxs(clustlike, value=TRUE)
  for (j in 1:K) {
    clustlike[, j] <- exp(clustlike[, j] - tempmax)
  }
  #tempsum <- apply(clustlike, 1, sum)
  tempsum <- Rfast::rowsums(clustlike)
  for (j in 1:K) {
    clustlike[, j] <- clustlike[, j]/tempsum
  }
  p.post <- matrix(0, xrow, xcol)
  for (j in 1:K) {
    for (i in 1:xcol) {
      p.post[, i] <- p.post[, i] + clustlike[, j] * condlike[[i]][,
                                                                  j]
    }
  }
  loglike.old <- loglike.old - (sum(log(p)) + sum(log(q) +
                                                    log(1 - q)))/xrow
  loglike.old <- loglike.old * xrow
  result <- list(p.post = p.post, motif.prior = p, motif.q = q,
                 loglike = loglike.old, clustlike=clustlike, condlike=condlike)
}

## Fit using (0,0,...,0) and (1,1,...,1)
cmfitall<-function(x, type, tol=1e-3, max.iter=100) {
  ## initialize
  xrow<-nrow(x)
  xcol<-ncol(x)
  loglike0<-list()
  loglike1<-list()
  p<-0.01

  ## compute loglikelihood
  L0<-matrix(0,xrow,1)
  L1<-matrix(0,xrow,1)
  for(i in 1:xcol) {
    f0<-type[[i]][[1]]
    f0param<-type[[i]][[2]]
    f1<-type[[i]][[3]]
    f1param<-type[[i]][[4]]
    loglike0[[i]]<-f0(x[,i],f0param)
    loglike1[[i]]<-f1(x[,i],f1param)
    L0<-L0+loglike0[[i]]
    L1<-L1+loglike1[[i]]
  }


  ## EM algorithm to get MLE of p and q
  loglike.old <- -1e10
  for(i.iter in 1:max.iter) {
    if((i.iter%%50) == 0) {
      print(paste("We have run the first ", i.iter, " iterations",sep=""))
    }
    err<-tol+1

    ## compute posterior cluster membership
    clustlike<-matrix(0,xrow,2)
    clustlike[,1]<-log(1-p)+L0
    clustlike[,2]<-log(p)+L1

    tempmax<-apply(clustlike,1,max)
    for(j in 1:2) {
      clustlike[,j]<-exp(clustlike[,j]-tempmax)
    }
    tempsum<-apply(clustlike,1,sum)

    ## update motif occurrence rate
    for(j in 1:2) {
      clustlike[,j]<-clustlike[,j]/tempsum
    }

    p.new<-(sum(clustlike[,2])+1)/(xrow+2)

    ## evaluate convergence
    err<-abs(p.new-p)/p

    ## evaluate whether the log.likelihood increases
    loglike.new<-(sum(tempmax+log(tempsum))+log(p.new)+log(1-p.new))/xrow

    loglike.old<-loglike.new
    p<-p.new

    if(err<tol) {
      break;
    }
  }

  ## compute posterior p
  clustlike<-matrix(0,xrow,2)
  clustlike[,1]<-log(1-p)+L0
  clustlike[,2]<-log(p)+L1

  tempmax<-apply(clustlike,1,max)
  for(j in 1:2) {
    clustlike[,j]<-exp(clustlike[,j]-tempmax)
  }
  tempsum<-apply(clustlike,1,sum)

  for(j in 1:2) {
    clustlike[,j]<-clustlike[,j]/tempsum
  }

  p.post<-matrix(0,xrow,xcol)
  for(i in 1:xcol) {
    p.post[,i]<-clustlike[,2]
  }

  ## return

  #calculate back loglikelihood
  loglike.old<-loglike.old-(log(p)+log(1-p))/xrow
  loglike.old<-loglike.old*xrow
  result<-list(p.post=p.post, motif.prior=p, loglike=loglike.old)
}

## Fit each dataset separately
cmfitsep<-function(x, type, tol=1e-3, max.iter=100) {
  ## initialize
  xrow<-nrow(x)
  xcol<-ncol(x)
  loglike0<-list()
  loglike1<-list()
  p<-0.01*rep(1,xcol)
  loglike.final<-rep(0,xcol)

  ## compute loglikelihood
  for(i in 1:xcol) {
    f0<-type[[i]][[1]]
    f0param<-type[[i]][[2]]
    f1<-type[[i]][[3]]
    f1param<-type[[i]][[4]]
    loglike0[[i]]<-f0(x[,i],f0param)
    loglike1[[i]]<-f1(x[,i],f1param)
  }

  p.post<-matrix(0,xrow,xcol)

  ## EM algorithm to get MLE of p
  for(coli in 1:xcol) {
    loglike.old <- -1e10
    for(i.iter in 1:max.iter) {
      if((i.iter%%50) == 0) {
        print(paste("We have run the first ", i.iter, " iterations",sep=""))
      }
      err<-tol+1

      ## compute posterior cluster membership
      clustlike<-matrix(0,xrow,2)
      clustlike[,1]<-log(1-p[coli])+loglike0[[coli]]
      clustlike[,2]<-log(p[coli])+loglike1[[coli]]

      tempmax<-apply(clustlike,1,max)
      for(j in 1:2) {
        clustlike[,j]<-exp(clustlike[,j]-tempmax)
      }
      tempsum<-apply(clustlike,1,sum)

      ## evaluate whether the log.likelihood increases
      loglike.new<-sum(tempmax+log(tempsum))/xrow

      ## update motif occurrence rate
      for(j in 1:2) {
        clustlike[,j]<-clustlike[,j]/tempsum
      }

      p.new<-(sum(clustlike[,2]))/(xrow)

      ## evaluate convergence
      err<-abs(p.new-p[coli])/p[coli]
      loglike.old<-loglike.new
      p[coli]<-p.new

      if(err<tol) {
        break;
      }
    }

    ## compute posterior p
    clustlike<-matrix(0,xrow,2)
    clustlike[,1]<-log(1-p[coli])+loglike0[[coli]]
    clustlike[,2]<-log(p[coli])+loglike1[[coli]]

    tempmax<-apply(clustlike,1,max)
    for(j in 1:2) {
      clustlike[,j]<-exp(clustlike[,j]-tempmax)
    }
    tempsum<-apply(clustlike,1,sum)

    for(j in 1:2) {
      clustlike[,j]<-clustlike[,j]/tempsum
    }

    p.post[,coli]<-clustlike[,2]
    loglike.final[coli]<-loglike.old
  }


  ## return
  loglike.final<-loglike.final*xrow
  result<-list(p.post=p.post, motif.prior=p, loglike=loglike.final)
}

## Fit the full model
cmfitfull<-function(x, type, tol=1e-3, max.iter=100) {
  ## initialize
  xrow<-nrow(x)
  xcol<-ncol(x)
  loglike0<-list()
  loglike1<-list()
  K<-2^xcol
  p<-rep(1,K)/K
  pattern<-rep(0,xcol)
  patid<-matrix(0,K,xcol)

  ## compute loglikelihood
  for(i in 1:xcol) {
    f0<-type[[i]][[1]]
    f0param<-type[[i]][[2]]
    f1<-type[[i]][[3]]
    f1param<-type[[i]][[4]]
    loglike0[[i]]<-f0(x[,i],f0param)
    loglike1[[i]]<-f1(x[,i],f1param)
  }
  L<-matrix(0,xrow,K)
  for(i in 1:K)
  {
    patid[i,]<-pattern
    for(j in 1:xcol) {
      if(pattern[j] < 0.5) {
        L[,i]<-L[,i]+loglike0[[j]]
      } else {
        L[,i]<-L[,i]+loglike1[[j]]
      }
    }

    if(i < K) {
      pattern[xcol]<-pattern[xcol]+1
      j<-xcol
      while(pattern[j] > 1) {
        pattern[j]<-0
        j<-j-1
        pattern[j]<-pattern[j]+1
      }
    }
  }

  ## EM algorithm to get MLE of p and q
  loglike.old <- -1e10
  for(i.iter in 1:max.iter) {
    if((i.iter%%50) == 0) {
      print(paste("We have run the first ", i.iter, " iterations",sep=""))
    }
    err<-tol+1

    ## compute posterior cluster membership
    clustlike<-matrix(0,xrow,K)
    for(j in 1:K) {
      clustlike[,j]<-log(p[j])+L[,j]
    }

    tempmax<-apply(clustlike,1,max)
    for(j in 1:K) {
      clustlike[,j]<-exp(clustlike[,j]-tempmax)
    }
    tempsum<-apply(clustlike,1,sum)

    ## update motif occurrence rate
    for(j in 1:K) {
      clustlike[,j]<-clustlike[,j]/tempsum
    }

    p.new<-(apply(clustlike,2,sum)+1)/(xrow+K)

    ## evaluate convergence
    err<-max(abs(p.new-p)/p)

    ## evaluate whether the log.likelihood increases
    loglike.new<-(sum(tempmax+log(tempsum))+sum(log(p.new)))/xrow

    loglike.old<-loglike.new
    p<-p.new

    if(err<tol) {
      break;
    }
  }

  ## compute posterior p
  clustlike<-matrix(0,xrow,K)
  for(j in 1:K) {
    clustlike[,j]<-log(p[j])+L[,j]
  }

  tempmax<-apply(clustlike,1,max)
  for(j in 1:K) {
    clustlike[,j]<-exp(clustlike[,j]-tempmax)
  }
  tempsum<-apply(clustlike,1,sum)

  for(j in 1:K) {
    clustlike[,j]<-clustlike[,j]/tempsum
  }

  p.post<-matrix(0,xrow,xcol)
  for(j in 1:K) {
    for(i in 1:xcol) {
      if(patid[j,i] > 0.5) {
        p.post[,i]<-p.post[,i]+clustlike[,j]
      }
    }
  }

  ## return
  #calculate back loglikelihood
  loglike.old<-loglike.old-sum(log(p))/xrow
  loglike.old<-loglike.old*xrow
  result<-list(p.post=p.post, motif.prior=p, loglike=loglike.old)
}

generatetype<-function(limfitted)
{
  jtype<-list()
  df<-limfitted$g1num+limfitted$g2num-2+limfitted$df0
  for(j in 1:limfitted$compnum)
  {
    jtype[[j]]<-list(f0=modt.f0.loglike, f0.param=df[j], f1=modt.f1.loglike, f1.param=c(df[j],limfitted$g1num[j],limfitted$g2num[j],limfitted$v0[j]))
  }
  jtype
}

cormotiffit <- function(exprs, groupid=NULL, compid=NULL, K=1, tol=1e-3,
                        max.iter=100, BIC=TRUE, norm.factor.method="TMM",
                        voom.normalize.method = "none", runtype=c("logCPM","counts","limmafits"), each=3)
{
  #Input can be either a normalized matrix, a count matrix, or a list of limma fits. Dispatch the correct
  # limmafit accordingly.
  limfitted <- list()
  if (runtype=="counts") {
    limfitted <- limmafit.counts(exprs,groupid,compid, norm.factor.method, voom.normalize.method)
  } else if (runtype=="logCPM") {
    limfitted <- limmafit.default(exprs,groupid,compid)
  } else if (runtype=="limmafits") {
    limfitted <- limmafit.list(exprs)
  } else {
    stop("runtype must be one of 'logCPM', 'counts', or 'limmafits'")
  }


  jtype<-generatetype(limfitted)
  fitresult<-list()
  ks <- rep(K, each = each)
  fitresult <- bplapply(1:length(ks), function(i, x, type, ks, tol, max.iter) {
    cmfit.X(x, type, K = ks[i], tol = tol, max.iter = max.iter)
  }, x=limfitted$t, type=jtype, ks=ks, tol=tol, max.iter=max.iter)

  best.fitresults <- list()
  for (i in 1:length(K)) {
    w.k <- which(ks==K[i])
    this.bic <- c()
    for (j in w.k) this.bic[j] <- -2 * fitresult[[j]]$loglike + (K[i] - 1 + K[i] * limfitted$compnum) * log(dim(limfitted$t)[1])
    w.min <- which(this.bic == min(this.bic, na.rm = TRUE))[1]
    best.fitresults[[i]] <- fitresult[[w.min]]
  }
  fitresult <- best.fitresults

  bic <- rep(0, length(K))
  aic <- rep(0, length(K))
  loglike <- rep(0, length(K))
  for (i in 1:length(K)) loglike[i] <- fitresult[[i]]$loglike
  for (i in 1:length(K)) bic[i] <- -2 * fitresult[[i]]$loglike + (K[i] - 1 + K[i] * limfitted$compnum) * log(dim(limfitted$t)[1])
  for (i in 1:length(K)) aic[i] <- -2 * fitresult[[i]]$loglike + 2 * (K[i] - 1 + K[i] * limfitted$compnum)
  if(BIC==TRUE) {
    bestflag=which(bic==min(bic))
  }
  else {
    bestflag=which(aic==min(aic))
  }
  result<-list(bestmotif=fitresult[[bestflag]],bic=cbind(K,bic),
               aic=cbind(K,aic),loglike=cbind(K,loglike), allmotifs=fitresult)

}

cormotiffitall<-function(exprs,groupid,compid, tol=1e-3, max.iter=100)
{
  limfitted<-limmafit(exprs,groupid,compid)
  jtype<-generatetype(limfitted)
  fitresult<-cmfitall(limfitted$t,type=jtype,tol=1e-3,max.iter=max.iter)
}

cormotiffitsep<-function(exprs,groupid,compid, tol=1e-3, max.iter=100)
{
  limfitted<-limmafit(exprs,groupid,compid)
  jtype<-generatetype(limfitted)
  fitresult<-cmfitsep(limfitted$t,type=jtype,tol=1e-3,max.iter=max.iter)
}

cormotiffitfull<-function(exprs,groupid,compid, tol=1e-3, max.iter=100)
{
  limfitted<-limmafit(exprs,groupid,compid)
  jtype<-generatetype(limfitted)
  fitresult<-cmfitfull(limfitted$t,type=jtype,tol=1e-3,max.iter=max.iter)
}

plotIC<-function(fitted_cormotif)
{
  oldpar<-par(mfrow=c(1,2))
  plot(fitted_cormotif$bic[,1], fitted_cormotif$bic[,2], type="b",xlab="Motif Number", ylab="BIC", main="BIC")
  plot(fitted_cormotif$aic[,1], fitted_cormotif$aic[,2], type="b",xlab="Motif Number", ylab="AIC", main="AIC")
}

plotMotif<-function(fitted_cormotif,title="")
{
  layout(matrix(1:2,ncol=2))
  u<-1:dim(fitted_cormotif$bestmotif$motif.q)[2]
  v<-1:dim(fitted_cormotif$bestmotif$motif.q)[1]
  image(u,v,t(fitted_cormotif$bestmotif$motif.q),
        col=gray(seq(from=1,to=0,by=-0.1)),xlab="Study",yaxt = "n",
        ylab="Corr. Motifs",main=paste(title,"pattern",sep=" "))
  axis(2,at=1:length(v))
  for(i in 1:(length(u)+1))
  {
    abline(v=(i-0.5))
  }
  for(i in 1:(length(v)+1))
  {
    abline(h=(i-0.5))
  }
  Ng=10000
  if(is.null(fitted_cormotif$bestmotif$p.post)!=TRUE)
    Ng=nrow(fitted_cormotif$bestmotif$p.post)
  genecount=floor(fitted_cormotif$bestmotif$motif.p*Ng)
  NK=nrow(fitted_cormotif$bestmotif$motif.q)
  plot(0,0.7,pch=".",xlim=c(0,1.2),ylim=c(0.75,NK+0.25),
       frame.plot=FALSE,axes=FALSE,xlab="No. of genes",ylab="", main=paste(title,"frequency",sep=" "))
  segments(0,0.7,fitted_cormotif$bestmotif$motif.p[1],0.7)
  rect(0,1:NK-0.3,fitted_cormotif$bestmotif$motif.p,1:NK+0.3,
       col="dark grey")
  mtext(1:NK,at=1:NK,side=2,cex=0.8)
  text(fitted_cormotif$bestmotif$motif.p+0.15,1:NK,
       labels=floor(fitted_cormotif$bestmotif$motif.p*Ng))
}
```


```{r Cormotif, eval=TRUE, warning=FALSE, include=FALSE}
#####Add in the dataframe - gene expression matrix####

annot_data <- annot %>% dplyr::select("Tx_Time", "Time", "Tx", "Ind", "samples")

Cormotif <- counts_DE_df %>% cpm(., log = TRUE)
Cormotif_df <- as.data.frame(Cormotif)

groupid <- rep(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 7)

compid <- data.frame(c1 = c(1, 2, 4, 5, 7, 8), c2 = c(3, 3, 6, 6, 9, 9))


```

```{r Cormotif Next, include=FALSE}

set.seed(12345)
initial_cormotif <- cormotiffit(exprs = Cormotif,
                                groupid = groupid,
                                compid = compid,
                                K=1:10  , max.iter = 500, runtype = "logCPM")

#only need to run this once! 
#save this to an object so I can retrieve it as needed

#saveRDS(initial_cormotif, "data/initial_cormotif.RDS")

```

AIC = Akaike Information Criterion - favors models better at prediction even if more complex
BIC = Bayesian Information Criterion - prioritizes simpler models, greater penalty on models with more parameters (especially helpful with larger datasets)
By using these both, you can find the model that is the most suited to your data and find the motifs most likely to be present
```{r Cormotif Motifs}

plotIC(initial_cormotif)

initial_cormotif$bic

```

Now I can plot the motifs generated by cormotiffit - this plots the model with the lowest BIC (K=3)
```{r Cormotif Motif Plots}

plotMotif(initial_cormotif)

```

```{r Gene Probabilities Cormotif}

topgenelist <- generank(initial_cormotif$bestmotif$p.post)
rownames(topgenelist) <- rownames(Cormotif_df)

motif_prob <- initial_cormotif$bestmotif$clustlike
rownames(motif_prob) <- rownames(topgenelist)
#saveRDS(motif_prob, "data/Cormotif_prob_gene_list.RDS")

#Define the gene probability groups - I have 3
clust1 <- motif_prob %>% 
  as.data.frame() %>% 
  filter(V1>0.5) %>% 
  rownames

length(clust1)
#12004
#is this clust1 a non-response?

clust2 <- motif_prob %>% 
  as.data.frame() %>% 
  filter(V2>0.5) %>% 
  rownames

length(clust2)
#491
#is clust2 a dox-specific late response?

clust3 <- motif_prob %>% 
  as.data.frame() %>% 
  filter(V3>0.5) %>% 
  rownames

length(clust3)
#1501
#is clust3 a dox-specific early response?

clusterdata <- data.frame(
  Category = c("Non-response", "DOX Late Response", "DOX Early Response"), 
  Value = c(12004, 491, 1501)
)

piecolors <- c("Non-response" = "#007896", 
               "DOX Late Response" = "#58508D", 
               "DOX Early Response" = "#BC5090")

#make a piechart of these distributions
clusterdata %>% ggplot(aes(x = "", y = Value, fill = Category))+
  geom_bar(width = 1, stat = "identity")+
  coord_polar("y", start = 0)+
  geom_text(aes(label = Value),
            position = position_stack(vjust = 0.5),
            size = 4, color = "black")+
  labs(title = "Distribution of Gene Clusters Identified By Cormotif", x = NULL, y = NULL)+
  theme_void()+
  scale_fill_manual(values = piecolors)

```

